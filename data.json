{"source_files":[{"name":"public/app/app.js","source":"/**\n * main app level module\n */\ndefine([\n  'angular',\n  'jquery',\n  'lodash',\n  'require',\n  'config',\n  'bootstrap',\n  'angular-route',\n  'angular-sanitize',\n  'angular-strap',\n  'angular-dragdrop',\n  'extend-jquery',\n  'bindonce',\n],\nfunction (angular, $, _, appLevelRequire) {\n\n  \"use strict\";\n\n  var app = angular.module('grafana', []),\n    // we will keep a reference to each module defined before boot, so that we can\n    // go back and allow it to define new features later. Once we boot, this will be false\n    pre_boot_modules = [],\n    // these are the functions that we need to call to register different\n    // features if we define them after boot time\n    register_fns = {};\n\n  // This stores the grafana version number\n  app.constant('grafanaVersion',\"@grafanaVersion@\");\n\n  // Use this for cache busting partials\n  app.constant('cacheBust',\"cache-bust=\"+Date.now());\n\n  /**\n   * Tells the application to watch the module, once bootstraping has completed\n   * the modules controller, service, etc. functions will be overwritten to register directly\n   * with this application.\n   * @param  {[type]} module [description]\n   * @return {[type]}        [description]\n   */\n  app.useModule = function (module) {\n    if (pre_boot_modules) {\n      pre_boot_modules.push(module);\n    } else {\n      _.extend(module, register_fns);\n    }\n    return module;\n  };\n\n  app.config(function($locationProvider, $controllerProvider, $compileProvider, $filterProvider, $provide) {\n    // this is how the internet told me to dynamically add modules :/\n    register_fns.controller = $controllerProvider.register;\n    register_fns.directive  = $compileProvider.directive;\n    register_fns.factory    = $provide.factory;\n    register_fns.service    = $provide.service;\n    register_fns.filter     = $filterProvider.register;\n  });\n\n  var apps_deps = [\n    'ngRoute',\n    'ngSanitize',\n    '$strap.directives',\n    'ang-drag-drop',\n    'grafana',\n    'pasvaz.bindonce'\n  ];\n\n  var module_types = ['controllers', 'directives', 'factories', 'services', 'filters', 'routes'];\n\n  _.each(module_types, function (type) {\n    var module_name = 'grafana.'+type;\n    // create the module\n    app.useModule(angular.module(module_name, []));\n    // push it into the apps dependencies\n    apps_deps.push(module_name);\n  });\n\n  var preBootRequires = [\n    'services/all',\n    'features/all',\n    'controllers/all',\n    'directives/all',\n    'filters/all',\n    'components/partials',\n    'routes/all',\n  ];\n\n  app.boot = function() {\n    require(preBootRequires, function () {\n\n      // disable tool tip animation\n      $.fn.tooltip.defaults.animation = false;\n\n      // bootstrap the app\n      angular\n        .element(document)\n        .ready(function() {\n          angular.bootstrap(document, apps_deps)\n            .invoke(['$rootScope', function ($rootScope) {\n              _.each(pre_boot_modules, function (module) {\n                _.extend(module, register_fns);\n              });\n              pre_boot_modules = false;\n\n              $rootScope.requireContext = appLevelRequire;\n              $rootScope.require = function (deps, fn) {\n                var $scope = this;\n                $scope.requireContext(deps, function () {\n                  var deps = _.toArray(arguments);\n                  // Check that this is a valid scope.\n                  if($scope.$id) {\n                    $scope.$apply(function () {\n                      fn.apply($scope, deps);\n                    });\n                  }\n                });\n              };\n            }]);\n        });\n    });\n  };\n\n  return app;\n});\n","coverage":[null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,1,null,null,1,null,null,null,null,null,null,null,null,1,7,7,null,0,null,7,null,null,1,null,0,0,0,0,0,null,null,1,null,null,null,null,null,null,null,null,1,null,1,6,null,6,null,6,null,null,1,null,null,null,null,null,null,null,null,null,1,0,null,null,0,null,null,0,null,null,0,null,0,0,null,0,null,0,0,0,0,0,null,0,0,0,null,null,null,null,null,null,null,null,null,1,null,null]},{"name":"public/app/components/config.js","source":"define([\n  'settings',\n],\nfunction (Settings) {\n  \"use strict\";\n\n  var bootData = window.grafanaBootData || { settings: {} };\n  var options = bootData.settings;\n\n  return new Settings(options);\n\n});\n","coverage":[1,null,null,null,null,null,1,1,null,1,null,null,null]},{"name":"public/app/components/settings.js","source":"define([\n  'lodash',\n],\nfunction (_) {\n  \"use strict\";\n\n  return function Settings (options) {\n    /**\n     * To add a setting, you MUST define a default. Also,\n     * THESE ARE ONLY DEFAULTS.\n     * They are overridden by config.js in the root directory\n     * @type {Object}\n     */\n    var defaults = {\n      datasources                   : {},\n      window_title_prefix           : 'Grafana - ',\n      panels                        : {\n        'graph':      { path: 'panels/graph',      name: 'Graph' },\n        'singlestat': { path: 'panels/singlestat', name: 'Single stat' },\n        'text':       { path: 'panels/text',       name: 'Text' },\n        'dashlist':   { path: 'panels/dashlist',   name: 'Dashboard list' },\n      },\n      new_panel_title: 'no title (click here)',\n      plugins: {},\n      default_route: '/dashboard/file/default.json',\n      playlist_timespan: \"1m\",\n      unsaved_changes_warning: true,\n      search: { max_results: 100 },\n      appSubUrl: \"\"\n    };\n\n    var settings = _.extend({}, defaults, options);\n\n    // var parseBasicAuth = function(datasource) {\n    //   var passwordEnd = datasource.url.indexOf('@');\n    //   if (passwordEnd > 0) {\n    //     var userStart = datasource.url.indexOf('//') + 2;\n    //     var userAndPassword = datasource.url.substring(userStart, passwordEnd);\n    //     var bytes = crypto.charenc.Binary.stringToBytes(userAndPassword);\n    //     datasource.basicAuth = crypto.util.bytesToBase64(bytes);\n    //\n    //     var urlHead = datasource.url.substring(0, userStart);\n    //     datasource.url = urlHead + datasource.url.substring(passwordEnd + 1);\n    //   }\n    //\n    //   return datasource;\n    // };\n    //\n    // _.each(settings.datasources, function(datasource, key) {\n    //   datasource.name = key;\n    //   if (datasource.url) { parseBasicAuth(datasource); }\n    //   if (datasource.type === 'influxdb') { parseMultipleHosts(datasource); }\n    // });\n\n    return settings;\n  };\n});\n","coverage":[1,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null]},{"name":"public/app/components/lodash.extended.js","source":"define([\n  'lodash-src'\n],\nfunction () {\n  'use strict';\n\n  var _ = window._;\n\n  /*\n    Mixins :)\n  */\n  _.mixin({\n    move: function (array, fromIndex, toIndex) {\n      array.splice(toIndex, 0, array.splice(fromIndex, 1)[0]);\n      return array;\n    },\n    // If variable is value, then return alt. If variable is anything else, return value;\n    toggle: function (variable, value, alt) {\n      return variable === value ? alt : value;\n    },\n    toggleInOut: function(array,value) {\n      if(_.contains(array,value)) {\n        array = _.without(array,value);\n      } else {\n        array.push(value);\n      }\n      return array;\n    }\n  });\n\n  return _;\n});\n","coverage":[1,null,null,null,null,null,1,null,null,null,null,1,null,0,0,null,null,null,0,null,null,0,0,null,0,null,0,null,null,null,1,null,null]},{"name":"public/app/components/extend-jquery.js","source":"define(['jquery'],\nfunction ($) {\n  'use strict';\n\n  /**\n   * jQuery extensions\n   */\n  var $win = $(window);\n\n  $.fn.place_tt = (function () {\n    var defaults = {\n      offset: 5,\n    };\n\n    return function (x, y, opts) {\n      opts = $.extend(true, {}, defaults, opts);\n      return this.each(function () {\n        var $tooltip = $(this), width, height;\n\n        $tooltip.addClass('grafana-tooltip');\n\n        $(\"#tooltip\").remove();\n        $tooltip.appendTo(document.body);\n\n        width = $tooltip.outerWidth(true);\n        height = $tooltip.outerHeight(true);\n\n        $tooltip.css('left', x + opts.offset + width > $win.width() ? x - opts.offset - width : x + opts.offset);\n        $tooltip.css('top', y + opts.offset + height > $win.height() ? y - opts.offset - height : y + opts.offset);\n      });\n    };\n  })();\n\n  return $;\n});\n","coverage":[1,null,null,null,null,null,null,1,null,1,1,null,null,null,1,0,0,0,null,0,null,0,0,null,0,0,null,0,0,null,null,null,null,1,null,null]},{"name":"public/app/plugins/datasource/graphite/lexer.js","source":"define([\n  'lodash'\n], function(_) {\n  'use strict';\n\n  // This is auto generated from the unicode tables.\n  // The tables are at:\n  // http://www.fileformat.info/info/unicode/category/Lu/list.htm\n  // http://www.fileformat.info/info/unicode/category/Ll/list.htm\n  // http://www.fileformat.info/info/unicode/category/Lt/list.htm\n  // http://www.fileformat.info/info/unicode/category/Lm/list.htm\n  // http://www.fileformat.info/info/unicode/category/Lo/list.htm\n  // http://www.fileformat.info/info/unicode/category/Nl/list.htm\n\n  var unicodeLetterTable = [\n    170, 170, 181, 181, 186, 186, 192, 214,\n    216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750,\n    880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908,\n    910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366,\n    1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610,\n    1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775,\n    1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957,\n    1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069,\n    2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2308, 2361,\n    2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431,\n    2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482,\n    2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529,\n    2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608,\n    2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654,\n    2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736,\n    2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785,\n    2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867,\n    2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929,\n    2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970,\n    2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001,\n    3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123,\n    3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212,\n    3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261,\n    3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344,\n    3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455,\n    3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526,\n    3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716,\n    3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743,\n    3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760,\n    3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805,\n    3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138,\n    4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198,\n    4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4304, 4346,\n    4348, 4348, 4352, 4680, 4682, 4685, 4688, 4694, 4696, 4696,\n    4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789,\n    4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880,\n    4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740,\n    5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900,\n    5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000,\n    6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312,\n    6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516,\n    6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823,\n    6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7104, 7141,\n    7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409,\n    7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013,\n    8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061,\n    8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140,\n    8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188,\n    8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455,\n    8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486,\n    8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521,\n    8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358,\n    11360, 11492, 11499, 11502, 11520, 11557, 11568, 11621,\n    11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694,\n    11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726,\n    11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295,\n    12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438,\n    12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589,\n    12593, 12686, 12704, 12730, 12784, 12799, 13312, 13312,\n    19893, 19893, 19968, 19968, 40907, 40907, 40960, 42124,\n    42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539,\n    42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783,\n    42786, 42888, 42891, 42894, 42896, 42897, 42912, 42921,\n    43002, 43009, 43011, 43013, 43015, 43018, 43020, 43042,\n    43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259,\n    43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442,\n    43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595,\n    43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697,\n    43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714,\n    43739, 43741, 43777, 43782, 43785, 43790, 43793, 43798,\n    43808, 43814, 43816, 43822, 43968, 44002, 44032, 44032,\n    55203, 55203, 55216, 55238, 55243, 55291, 63744, 64045,\n    64048, 64109, 64112, 64217, 64256, 64262, 64275, 64279,\n    64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316,\n    64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433,\n    64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019,\n    65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370,\n    65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495,\n    65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594,\n    65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786,\n    65856, 65908, 66176, 66204, 66208, 66256, 66304, 66334,\n    66352, 66378, 66432, 66461, 66464, 66499, 66504, 66511,\n    66513, 66517, 66560, 66717, 67584, 67589, 67592, 67592,\n    67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669,\n    67840, 67861, 67872, 67897, 68096, 68096, 68112, 68115,\n    68117, 68119, 68121, 68147, 68192, 68220, 68352, 68405,\n    68416, 68437, 68448, 68466, 68608, 68680, 69635, 69687,\n    69763, 69807, 73728, 74606, 74752, 74850, 77824, 78894,\n    92160, 92728, 110592, 110593, 119808, 119892, 119894, 119964,\n    119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980,\n    119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069,\n    120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121,\n    120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144,\n    120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570,\n    120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686,\n    120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779,\n    131072, 131072, 173782, 173782, 173824, 173824, 177972, 177972,\n    177984, 177984, 178205, 178205, 194560, 195101\n  ];\n\n  var identifierStartTable = [];\n\n  for (var i = 0; i < 128; i++) {\n    identifierStartTable[i] =\n      i >= 48 && i <= 57 || // 0-9\n      i === 36 ||           // $\n      i >= 65 && i <= 90 || // A-Z\n      i === 95 ||           // _\n      i === 45 ||           // -\n      i === 42 ||           // *\n      i === 58 ||           // :\n      i === 91 ||           // templateStart [\n      i === 93 ||           // templateEnd ]\n      i === 63 ||           // ?\n      i === 37 ||           // %\n      i === 35 ||           // #\n      i === 61 ||           // =\n      i >= 97 && i <= 122;  // a-z\n  }\n\n  var identifierPartTable = [];\n\n  for (var i2 = 0; i2 < 128; i2++) {\n    identifierPartTable[i2] =\n      identifierStartTable[i2] || // $, _, A-Z, a-z\n      i2 >= 48 && i2 <= 57;        // 0-9\n  }\n\n  function Lexer(expression) {\n    this.input = expression;\n    this.char = 1;\n    this.from = 1;\n  }\n\n  Lexer.prototype = {\n\n    peek: function (i) {\n      return this.input.charAt(i || 0);\n    },\n\n    skip: function (i) {\n      i = i || 1;\n      this.char += i;\n      this.input = this.input.slice(i);\n    },\n\n    tokenize: function() {\n      var list = [];\n      var token;\n      while (token = this.next()) {\n        list.push(token);\n      }\n      return list;\n    },\n\n    next: function() {\n      this.from = this.char;\n\n      // Move to the next non-space character.\n      var start;\n      if (/\\s/.test(this.peek())) {\n        start = this.char;\n\n        while (/\\s/.test(this.peek())) {\n          this.from += 1;\n          this.skip();\n        }\n\n        if (this.peek() === \"\") { // EOL\n          return null;\n        }\n      }\n\n      var match = this.scanStringLiteral();\n      if (match) {\n        return match;\n      }\n\n      match =\n        this.scanPunctuator() ||\n        this.scanNumericLiteral() ||\n        this.scanIdentifier() ||\n        this.scanTemplateSequence();\n\n      if (match) {\n        this.skip(match.value.length);\n        return match;\n      }\n\n      // No token could be matched, give up.\n      return null;\n    },\n\n    scanTemplateSequence: function() {\n      if (this.peek() === '[' && this.peek(1) === '[') {\n        return {\n          type: 'templateStart',\n          value: '[[',\n          pos: this.char\n        };\n      }\n\n      if (this.peek() === ']' && this.peek(1) === ']') {\n        return {\n          type: 'templateEnd',\n          value: '[[',\n          pos: this.char\n        };\n      }\n\n      return null;\n    },\n\n      /*\n     * Extract a JavaScript identifier out of the next sequence of\n     * characters or return 'null' if its not possible. In addition,\n     * to Identifier this method can also produce BooleanLiteral\n     * (true/false) and NullLiteral (null).\n     */\n    scanIdentifier: function() {\n      var id = \"\";\n      var index = 0;\n      var type, char;\n\n      // Detects any character in the Unicode categories \"Uppercase\n      // letter (Lu)\", \"Lowercase letter (Ll)\", \"Titlecase letter\n      // (Lt)\", \"Modifier letter (Lm)\", \"Other letter (Lo)\", or\n      // \"Letter number (Nl)\".\n      //\n      // Both approach and unicodeLetterTable were borrowed from\n      // Google's Traceur.\n\n      function isUnicodeLetter(code) {\n        for (var i = 0; i < unicodeLetterTable.length;) {\n          if (code < unicodeLetterTable[i++]) {\n            return false;\n          }\n\n          if (code <= unicodeLetterTable[i++]) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      function isHexDigit(str) {\n        return (/^[0-9a-fA-F]$/).test(str);\n      }\n\n      var readUnicodeEscapeSequence = _.bind(function () {\n        /*jshint validthis:true */\n        index += 1;\n\n        if (this.peek(index) !== \"u\") {\n          return null;\n        }\n\n        var ch1 = this.peek(index + 1);\n        var ch2 = this.peek(index + 2);\n        var ch3 = this.peek(index + 3);\n        var ch4 = this.peek(index + 4);\n        var code;\n\n        if (isHexDigit(ch1) && isHexDigit(ch2) && isHexDigit(ch3) && isHexDigit(ch4)) {\n          code = parseInt(ch1 + ch2 + ch3 + ch4, 16);\n\n          if (isUnicodeLetter(code)) {\n            index += 5;\n            return \"\\\\u\" + ch1 + ch2 + ch3 + ch4;\n          }\n\n          return null;\n        }\n\n        return null;\n      }, this);\n\n      var getIdentifierStart = _.bind(function () {\n        /*jshint validthis:true */\n        var chr = this.peek(index);\n        var code = chr.charCodeAt(0);\n\n        if (chr === '*') {\n          index += 1;\n          return chr;\n        }\n\n        if (code === 92) {\n          return readUnicodeEscapeSequence();\n        }\n\n        if (code < 128) {\n          if (identifierStartTable[code]) {\n            index += 1;\n            return chr;\n          }\n\n          return null;\n        }\n\n        if (isUnicodeLetter(code)) {\n          index += 1;\n          return chr;\n        }\n\n        return null;\n      }, this);\n\n      var getIdentifierPart = _.bind(function () {\n        /*jshint validthis:true */\n        var chr = this.peek(index);\n        var code = chr.charCodeAt(0);\n\n        if (code === 92) {\n          return readUnicodeEscapeSequence();\n        }\n\n        if (code < 128) {\n          if (identifierPartTable[code]) {\n            index += 1;\n            return chr;\n          }\n\n          return null;\n        }\n\n        if (isUnicodeLetter(code)) {\n          index += 1;\n          return chr;\n        }\n\n        return null;\n      }, this);\n\n      char = getIdentifierStart();\n      if (char === null) {\n        return null;\n      }\n\n      id = char;\n      for (;;) {\n        char = getIdentifierPart();\n\n        if (char === null) {\n          break;\n        }\n\n        id += char;\n      }\n\n      switch (id) {\n      default:\n        type = \"identifier\";\n      }\n\n      return {\n        type: type,\n        value: id,\n        pos: this.char\n      };\n\n    },\n\n      /*\n     * Extract a numeric literal out of the next sequence of\n     * characters or return 'null' if its not possible. This method\n     * supports all numeric literals described in section 7.8.3\n     * of the EcmaScript 5 specification.\n     *\n     * This method's implementation was heavily influenced by the\n     * scanNumericLiteral function in the Esprima parser's source code.\n     */\n    scanNumericLiteral: function () {\n      var index = 0;\n      var value = \"\";\n      var length = this.input.length;\n      var char = this.peek(index);\n      var bad;\n\n      function isDecimalDigit(str) {\n        return (/^[0-9]$/).test(str);\n      }\n\n      function isOctalDigit(str) {\n        return (/^[0-7]$/).test(str);\n      }\n\n      function isHexDigit(str) {\n        return (/^[0-9a-fA-F]$/).test(str);\n      }\n\n      function isIdentifierStart(ch) {\n        return (ch === \"$\") || (ch === \"_\") || (ch === \"\\\\\") ||\n          (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\");\n      }\n\n      // handle negative num literals\n      if (char === '-') {\n        value += char;\n        index += 1;\n        char = this.peek(index);\n      }\n\n      // Numbers must start either with a decimal digit or a point.\n      if (char !== \".\" && !isDecimalDigit(char)) {\n        return null;\n      }\n\n      if (char !== \".\") {\n        value += this.peek(index);\n        index += 1;\n        char = this.peek(index);\n\n        if (value === \"0\") {\n          // Base-16 numbers.\n          if (char === \"x\" || char === \"X\") {\n            index += 1;\n            value += char;\n\n            while (index < length) {\n              char = this.peek(index);\n              if (!isHexDigit(char)) {\n                break;\n              }\n              value += char;\n              index += 1;\n            }\n\n            if (value.length <= 2) { // 0x\n              return {\n                type: 'number',\n                value: value,\n                isMalformed: true,\n                pos: this.char\n              };\n            }\n\n            if (index < length) {\n              char = this.peek(index);\n              if (isIdentifierStart(char)) {\n                return null;\n              }\n            }\n\n            return {\n              type: 'number',\n              value: value,\n              base: 16,\n              isMalformed: false,\n              pos: this.char\n            };\n          }\n\n          // Base-8 numbers.\n          if (isOctalDigit(char)) {\n            index += 1;\n            value += char;\n            bad = false;\n\n            while (index < length) {\n              char = this.peek(index);\n\n              // Numbers like '019' (note the 9) are not valid octals\n              // but we still parse them and mark as malformed.\n\n              if (isDecimalDigit(char)) {\n                bad = true;\n              } else if (!isOctalDigit(char)) {\n                break;\n              }\n              value += char;\n              index += 1;\n            }\n\n            if (index < length) {\n              char = this.peek(index);\n              if (isIdentifierStart(char)) {\n                return null;\n              }\n            }\n\n            return {\n              type: 'number',\n              value: value,\n              base: 8,\n              isMalformed: false\n            };\n          }\n\n          // Decimal numbers that start with '0' such as '09' are illegal\n          // but we still parse them and return as malformed.\n\n          if (isDecimalDigit(char)) {\n            index += 1;\n            value += char;\n          }\n        }\n\n        while (index < length) {\n          char = this.peek(index);\n          if (!isDecimalDigit(char)) {\n            break;\n          }\n          value += char;\n          index += 1;\n        }\n      }\n\n      // Decimal digits.\n\n      if (char === \".\") {\n        value += char;\n        index += 1;\n\n        while (index < length) {\n          char = this.peek(index);\n          if (!isDecimalDigit(char)) {\n            break;\n          }\n          value += char;\n          index += 1;\n        }\n      }\n\n      // Exponent part.\n\n      if (char === \"e\" || char === \"E\") {\n        value += char;\n        index += 1;\n        char = this.peek(index);\n\n        if (char === \"+\" || char === \"-\") {\n          value += this.peek(index);\n          index += 1;\n        }\n\n        char = this.peek(index);\n        if (isDecimalDigit(char)) {\n          value += char;\n          index += 1;\n\n          while (index < length) {\n            char = this.peek(index);\n            if (!isDecimalDigit(char)) {\n              break;\n            }\n            value += char;\n            index += 1;\n          }\n        } else {\n          return null;\n        }\n      }\n\n      if (index < length) {\n        char = this.peek(index);\n        if (!this.isPunctuator(char)) {\n          return null;\n        }\n      }\n\n      return {\n        type: 'number',\n        value: value,\n        base: 10,\n        pos: this.char,\n        isMalformed: !isFinite(value)\n      };\n    },\n\n    isPunctuator: function (ch1) {\n      switch (ch1) {\n      case \".\":\n      case \"(\":\n      case \")\":\n      case \",\":\n      case \"{\":\n      case \"}\":\n        return true;\n      }\n\n      return false;\n    },\n\n    scanPunctuator: function () {\n      var ch1 = this.peek();\n\n      if (this.isPunctuator(ch1)) {\n        return {\n          type: ch1,\n          value: ch1,\n          pos: this.char\n        };\n      }\n\n      return null;\n    },\n\n      /*\n     * Extract a string out of the next sequence of characters and/or\n     * lines or return 'null' if its not possible. Since strings can\n     * span across multiple lines this method has to move the char\n     * pointer.\n     *\n     * This method recognizes pseudo-multiline JavaScript strings:\n     *\n     *   var str = \"hello\\\n     *   world\";\n     */\n    scanStringLiteral: function () {\n      /*jshint loopfunc:true */\n      var quote = this.peek();\n\n      // String must start with a quote.\n      if (quote !== \"\\\"\" && quote !== \"'\") {\n        return null;\n      }\n\n      var value = \"\";\n\n      this.skip();\n\n      while (this.peek() !== quote) {\n        if (this.peek() === \"\") { // End Of Line\n          return {\n            type: 'string',\n            value: value,\n            isUnclosed: true,\n            quote: quote,\n            pos: this.char\n          };\n        }\n\n        var char = this.peek();\n        var jump = 1; // A length of a jump, after we're done\n                      // parsing this character.\n\n        value += char;\n        this.skip(jump);\n      }\n\n      this.skip();\n      return {\n        type: 'string',\n        value: value,\n        isUnclosed: false,\n        quote: quote,\n        pos: this.char\n      };\n    },\n\n  };\n\n  return Lexer;\n\n});\n","coverage":[1,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,128,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,128,null,null,null,null,1,47,47,47,null,null,1,null,null,2982,null,null,null,417,417,417,null,null,null,47,47,47,378,null,47,null,null,null,425,null,null,425,425,20,null,20,20,20,null,null,20,0,null,null,null,425,425,4,null,null,421,null,null,null,null,null,421,374,374,null,null,null,47,null,null,null,47,0,null,null,null,null,null,null,47,0,null,null,null,null,null,null,47,null,null,null,null,null,null,null,null,null,213,213,213,null,null,null,null,null,null,null,null,null,1,63,27909,0,null,null,27909,0,null,null,null,63,null,null,1,0,null,null,213,null,0,null,0,0,null,null,0,0,0,0,0,null,0,0,null,0,0,0,null,null,0,null,null,0,null,null,213,null,213,213,null,213,15,15,null,null,198,0,null,null,198,151,151,151,null,null,0,null,null,47,0,0,null,null,47,null,null,213,null,882,882,null,882,0,null,null,882,866,716,716,null,null,150,null,null,16,0,0,null,null,16,null,null,213,213,47,null,null,166,166,882,null,882,166,null,null,716,null,null,166,null,166,null,null,166,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,236,236,236,236,236,null,1,313,null,null,1,3,null,null,1,0,null,null,1,0,null,null,null,null,236,4,4,4,null,null,null,236,205,null,null,31,31,31,31,null,31,null,3,0,0,null,0,0,0,0,null,0,0,null,null,0,0,null,null,null,null,null,null,null,0,0,0,0,null,null,null,0,null,null,null,null,null,null,null,null,null,3,0,0,0,null,0,0,null,null,null,null,0,0,0,0,null,0,0,null,null,0,0,0,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,3,0,0,null,null,null,31,52,52,30,null,22,22,null,null,null,null,null,31,7,7,null,7,22,22,6,null,16,16,null,null,null,null,null,31,0,0,0,null,0,0,0,null,null,0,0,0,0,null,0,0,0,0,null,0,0,null,null,0,null,null,null,31,29,29,8,null,null,null,23,null,null,null,null,null,null,null,null,null,450,null,null,null,null,null,null,206,null,null,244,null,null,null,421,null,421,185,null,null,null,null,null,null,236,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,425,null,null,425,421,null,null,4,null,4,null,4,19,2,null,null,null,null,null,null,null,null,17,17,null,null,17,17,null,null,2,2,null,null,null,null,null,null,null,null,null,null,1,null,null,null]},{"name":"public/app/plugins/datasource/graphite/parser.js","source":"define([\n  './lexer'\n], function (Lexer) {\n  'use strict';\n\n  function Parser(expression) {\n    this.expression = expression;\n    this.lexer = new Lexer(expression);\n    this.tokens = this.lexer.tokenize();\n    this.index = 0;\n  }\n\n  Parser.prototype = {\n\n    getAst: function () {\n      return this.start();\n    },\n\n    start: function () {\n      try {\n        return this.functionCall() || this.metricExpression();\n      }\n      catch (e) {\n        return {\n          type: 'error',\n          message: e.message,\n          pos: e.pos\n        };\n      }\n    },\n\n    curlyBraceSegment: function() {\n      if (this.match('identifier', '{') || this.match('{')) {\n\n        var curlySegment = \"\";\n\n        while (!this.match('') && !this.match('}')) {\n          curlySegment += this.consumeToken().value;\n        }\n\n        if (!this.match('}')) {\n          this.errorMark(\"Expected closing '}'\");\n        }\n\n        curlySegment += this.consumeToken().value;\n\n        // if curly segment is directly followed by identifier\n        // include it in the segment\n        if (this.match('identifier')) {\n          curlySegment += this.consumeToken().value;\n        }\n\n        return {\n          type: 'segment',\n          value: curlySegment\n        };\n      }\n      else {\n        return null;\n      }\n    },\n\n    metricSegment: function() {\n      var curly = this.curlyBraceSegment();\n      if (curly) {\n        return curly;\n      }\n\n      if (this.match('identifier') || this.match('number')) {\n        // hack to handle float numbers in metric segments\n        var parts = this.consumeToken().value.split('.');\n        if (parts.length === 2) {\n          this.tokens.splice(this.index, 0, { type: '.' });\n          this.tokens.splice(this.index + 1, 0, { type: 'number', value: parts[1] });\n        }\n\n        return {\n          type: 'segment',\n          value: parts[0]\n        };\n      }\n\n      if (!this.match('templateStart')) {\n        this.errorMark('Expected metric identifier');\n      }\n\n      this.consumeToken();\n\n      if (!this.match('identifier')) {\n        this.errorMark('Expected identifier after templateStart');\n      }\n\n      var node = {\n        type: 'template',\n        value: this.consumeToken().value\n      };\n\n      if (!this.match('templateEnd')) {\n        this.errorMark('Expected templateEnd');\n      }\n\n      this.consumeToken();\n      return node;\n    },\n\n    metricExpression: function() {\n      if (!this.match('templateStart') &&\n          !this.match('identifier') &&\n          !this.match('number') &&\n          !this.match('{')) {\n        return null;\n      }\n\n      var node = {\n        type: 'metric',\n        segments: []\n      };\n\n      node.segments.push(this.metricSegment());\n\n      while (this.match('.')) {\n        this.consumeToken();\n\n        var segment = this.metricSegment();\n        if (!segment) {\n          this.errorMark('Expected metric identifier');\n        }\n\n        node.segments.push(segment);\n      }\n\n      return node;\n    },\n\n    functionCall: function() {\n      if (!this.match('identifier', '(')) {\n        return null;\n      }\n\n      var node = {\n        type: 'function',\n        name: this.consumeToken().value,\n      };\n\n      // consume left paranthesis\n      this.consumeToken();\n\n      node.params = this.functionParameters();\n\n      if (!this.match(')')) {\n        this.errorMark('Expected closing paranthesis');\n      }\n\n      this.consumeToken();\n\n      return node;\n    },\n\n    functionParameters: function () {\n      if (this.match(')') || this.match('')) {\n        return [];\n      }\n\n      var param =\n        this.functionCall() ||\n        this.numericLiteral() ||\n        this.seriesRefExpression() ||\n        this.metricExpression() ||\n        this.stringLiteral();\n\n      if (!this.match(',')) {\n        return [param];\n      }\n\n      this.consumeToken();\n      return [param].concat(this.functionParameters());\n    },\n\n    seriesRefExpression: function() {\n      if (!this.match('identifier')) {\n        return null;\n      }\n\n      var value = this.tokens[this.index].value;\n      if (!value.match(/\\#[A-Z]/)) {\n        return null;\n      }\n\n      var token = this.consumeToken();\n\n      return {\n        type: 'series-ref',\n        value: token.value\n      };\n    },\n\n    numericLiteral: function () {\n      if (!this.match('number')) {\n        return null;\n      }\n\n      return {\n        type: 'number',\n        value: parseFloat(this.consumeToken().value)\n      };\n    },\n\n    stringLiteral: function () {\n      if (!this.match('string')) {\n        return null;\n      }\n\n      var token = this.consumeToken();\n      if (token.isUnclosed) {\n        throw { message: 'Unclosed string parameter', pos: token.pos };\n      }\n\n      return {\n        type: 'string',\n        value: token.value\n      };\n    },\n\n    errorMark: function(text) {\n      var currentToken = this.tokens[this.index];\n      var type = currentToken ? currentToken.type : 'end of string';\n      throw {\n        message: text + \" instead found \" + type,\n        pos: currentToken ? currentToken.pos : this.lexer.char\n      };\n    },\n\n    // returns token value and incre\n    consumeToken: function() {\n      this.index++;\n      return this.tokens[this.index - 1];\n    },\n\n    matchToken: function(type, index) {\n      var token = this.tokens[this.index + index];\n      return (token === undefined && type === '') ||\n             token && token.type === type;\n    },\n\n    match: function(token1, token2) {\n      return this.matchToken(token1, 0) &&\n        (!token2 || this.matchToken(token2, 1));\n    },\n\n  };\n\n  return Parser;\n});\n","coverage":[1,null,null,null,null,1,35,35,35,35,null,null,1,null,null,35,null,null,null,35,35,null,null,3,null,null,null,null,null,null,null,null,89,null,3,null,3,11,null,null,3,0,null,null,3,null,null,null,3,1,null,null,3,null,null,null,null,null,86,null,null,null,null,89,89,3,null,null,86,null,85,85,2,2,null,null,85,null,null,null,null,null,1,1,null,null,0,null,0,0,null,null,0,null,null,null,null,0,0,null,null,0,0,null,null,null,36,null,null,null,4,null,null,32,null,null,null,null,32,null,32,57,null,57,56,0,null,null,56,null,null,31,null,null,null,91,60,null,null,31,null,null,null,null,null,31,null,31,null,30,1,null,null,29,null,29,null,null,null,56,0,null,null,56,null,null,null,null,null,null,55,30,null,null,25,25,null,null,null,32,3,null,null,29,29,21,null,null,8,null,8,null,null,null,null,null,null,48,32,null,null,16,null,null,null,null,null,null,3,0,null,null,3,3,1,null,null,2,null,null,null,null,null,null,2,2,2,null,null,null,null,null,null,null,300,300,null,null,null,996,996,null,null,null,null,846,null,null,null,null,null,1,null,null]},{"name":"public/app/plugins/datasource/graphite/gfunc.js","source":"define([\n  'lodash',\n  'jquery'\n],\nfunction (_, $) {\n  'use strict';\n\n  var index = [];\n  var categories = {\n    Combine: [],\n    Transform: [],\n    Calculate: [],\n    Filter: [],\n    Special: []\n  };\n\n  function addFuncDef(funcDef) {\n    funcDef.params = funcDef.params || [];\n    funcDef.defaultParams = funcDef.defaultParams || [];\n\n    if (funcDef.category) {\n      funcDef.category.push(funcDef);\n    }\n    index[funcDef.name] = funcDef;\n    index[funcDef.shortName || funcDef.name] = funcDef;\n  }\n\n  var optionalSeriesRefArgs = [\n    { name: 'other', type: 'value_or_series', optional: true },\n    { name: 'other', type: 'value_or_series', optional: true },\n    { name: 'other', type: 'value_or_series', optional: true },\n    { name: 'other', type: 'value_or_series', optional: true },\n    { name: 'other', type: 'value_or_series', optional: true }\n  ];\n\n  addFuncDef({\n    name: 'scaleToSeconds',\n    category: categories.Transform,\n    params: [{ name: 'seconds', type: 'int' }],\n    defaultParams: [1],\n  });\n\n  addFuncDef({\n    name: 'perSecond',\n    category: categories.Transform,\n    params: [],\n    defaultParams: [],\n  });\n\n  addFuncDef({\n    name: \"holtWintersForecast\",\n    category: categories.Calculate,\n  });\n\n  addFuncDef({\n    name: \"holtWintersConfidenceBands\",\n    category: categories.Calculate,\n    params: [{ name: \"delta\", type: 'int' }],\n    defaultParams: [3]\n  });\n\n  addFuncDef({\n    name: \"holtWintersAberration\",\n    category: categories.Calculate,\n    params: [{ name: \"delta\", type: 'int' }],\n    defaultParams: [3]\n  });\n\n  addFuncDef({\n    name: \"nPercentile\",\n    category: categories.Calculate,\n    params: [{ name: \"Nth percentile\", type: 'int' }],\n    defaultParams: [95]\n  });\n\n  addFuncDef({\n    name: 'diffSeries',\n    params: optionalSeriesRefArgs,\n    defaultParams: ['#A'],\n    category: categories.Calculate,\n  });\n\n  addFuncDef({\n    name: 'divideSeries',\n    params: optionalSeriesRefArgs,\n    defaultParams: ['#A'],\n    category: categories.Calculate,\n  });\n\n  addFuncDef({\n    name: 'asPercent',\n    params: optionalSeriesRefArgs,\n    defaultParams: ['#A'],\n    category: categories.Calculate,\n  });\n\n  addFuncDef({\n    name: 'group',\n    params: optionalSeriesRefArgs,\n    defaultParams: ['#A', '#B'],\n    category: categories.Combine,\n  });\n\n  addFuncDef({\n    name: 'mapSeries',\n    shortName: 'map',\n    params: [{ name: \"node\", type: 'int' }],\n    defaultParams: [3],\n    category: categories.Combine,\n  });\n\n  addFuncDef({\n    name: 'reduceSeries',\n    shortName: 'reduce',\n    params: [\n      { name: \"function\", type: 'string', options: ['asPercent', 'diffSeries', 'divideSeries'] },\n      { name: \"reduceNode\", type: 'int', options: [0,1,2,3,4,5,6,7,8,9,10,11,12,13] },\n      { name: \"reduceMatchers\", type: 'string' },\n      { name: \"reduceMatchers\", type: 'string' },\n    ],\n    defaultParams: ['asPercent', 2, 'used_bytes', 'total_bytes'],\n    category: categories.Combine,\n  });\n\n  addFuncDef({\n    name: 'sumSeries',\n    shortName: 'sum',\n    category: categories.Combine,\n    params: optionalSeriesRefArgs,\n    defaultParams: [''],\n  });\n\n  addFuncDef({\n    name: 'averageSeries',\n    shortName: 'avg',\n    category: categories.Combine,\n    params: optionalSeriesRefArgs,\n    defaultParams: [''],\n  });\n\n  addFuncDef({\n    name: 'isNonNull',\n    category: categories.Combine,\n  });\n\n  addFuncDef({\n    name: 'rangeOfSeries',\n    category: categories.Combine\n  });\n\n  addFuncDef({\n    name: 'percentileOfSeries',\n    category: categories.Combine,\n    params: [{ name: \"n\", type: \"int\" }, { name: \"interpolate\", type: \"select\", options: [\"true\", \"false\"] }],\n    defaultParams: [95, \"false\"]\n  });\n\n  addFuncDef({\n    name: 'sumSeriesWithWildcards',\n    category: categories.Combine,\n    params: [\n      { name: \"node\", type: \"int\" },\n      { name: \"node\", type: \"int\", optional: true },\n      { name: \"node\", type: \"int\", optional: true },\n      { name: \"node\", type: \"int\", optional: true }\n    ],\n    defaultParams: [3]\n  });\n\n  addFuncDef({\n    name: 'maxSeries',\n    shortName: 'max',\n    category: categories.Combine,\n  });\n\n  addFuncDef({\n    name: 'minSeries',\n    shortName: 'min',\n    category: categories.Combine,\n  });\n\n  addFuncDef({\n    name: 'averageSeriesWithWildcards',\n    category: categories.Combine,\n    params: [\n      { name: \"node\", type: \"int\" },\n      { name: \"node\", type: \"int\", optional: true },\n    ],\n    defaultParams: [3]\n  });\n\n  addFuncDef({\n    name: \"alias\",\n    category: categories.Special,\n    params: [{ name: \"alias\", type: 'string' }],\n    defaultParams: ['alias']\n  });\n\n  addFuncDef({\n    name: \"aliasSub\",\n    category: categories.Special,\n    params: [{ name: \"search\", type: 'string' }, { name: \"replace\", type: 'string' }],\n    defaultParams: ['', '\\\\1']\n  });\n\n  addFuncDef({\n    name: \"stacked\",\n    category: categories.Special,\n    params: [{ name: \"stack\", type: 'string' }],\n    defaultParams: ['stacked']\n  });\n\n  addFuncDef({\n    name: \"consolidateBy\",\n    category: categories.Special,\n    params: [\n      {\n        name: 'function',\n        type: 'string',\n        options: ['sum', 'average', 'min', 'max']\n      }\n    ],\n    defaultParams: ['max']\n  });\n\n  addFuncDef({\n    name: \"cumulative\",\n    category: categories.Special,\n    params: [],\n    defaultParams: []\n  });\n\n  addFuncDef({\n    name: \"groupByNode\",\n    category: categories.Special,\n    params: [\n      {\n        name: \"node\",\n        type: \"int\",\n        options: [0,1,2,3,4,5,6,7,8,9,10,12]\n      },\n      {\n        name: \"function\",\n        type: \"string\",\n        options: ['sum', 'avg']\n      }\n    ],\n    defaultParams: [3, \"sum\"]\n  });\n\n  addFuncDef({\n    name: 'aliasByNode',\n    category: categories.Special,\n    params: [\n      { name: \"node\", type: \"int\", options: [0,1,2,3,4,5,6,7,8,9,10,12] },\n      { name: \"node\", type: \"int\", options: [0,-1,-2,-3,-4,-5,-6,-7], optional: true },\n      { name: \"node\", type: \"int\", options: [0,-1,-2,-3,-4,-5,-6,-7], optional: true },\n      { name: \"node\", type: \"int\", options: [0,-1,-2,-3,-4,-5,-6,-7], optional: true },\n    ],\n    defaultParams: [3]\n  });\n\n  addFuncDef({\n    name: 'substr',\n    category: categories.Special,\n    params: [\n      { name: \"start\", type: \"int\", options: [-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,12] },\n      { name: \"stop\", type: \"int\", options: [-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,12] },\n    ],\n    defaultParams: [0, 0]\n  });\n\n  addFuncDef({\n    name: 'sortByName',\n    category: categories.Special\n  });\n\n  addFuncDef({\n    name: 'sortByMaxima',\n    category: categories.Special\n  });\n\n  addFuncDef({\n    name: 'sortByMinima',\n    category: categories.Special\n  });\n\n  addFuncDef({\n    name: 'sortByTotal',\n    category: categories.Special\n  });\n\n  addFuncDef({\n    name: 'aliasByMetric',\n    category: categories.Special,\n  });\n\n  addFuncDef({\n    name: 'randomWalk',\n    fake: true,\n    category: categories.Special,\n    params: [{ name: \"name\", type: \"string\", }],\n    defaultParams: ['randomWalk']\n  });\n\n  addFuncDef({\n    name: 'countSeries',\n    category: categories.Special\n  });\n\n  addFuncDef({\n    name: 'constantLine',\n    category: categories.Special,\n    params: [{ name: \"value\", type: \"int\", }],\n    defaultParams: [10]\n  });\n\n  addFuncDef({\n    name: 'cactiStyle',\n    category: categories.Special,\n  });\n\n  addFuncDef({\n    name: 'keepLastValue',\n    category: categories.Special,\n    params: [{ name: \"n\", type: \"int\", }],\n    defaultParams: [100]\n  });\n\n  addFuncDef({\n    name: 'scale',\n    category: categories.Transform,\n    params: [{ name: \"factor\", type: \"int\", }],\n    defaultParams: [1]\n  });\n\n  addFuncDef({\n    name: 'offset',\n    category: categories.Transform,\n    params: [{ name: \"amount\", type: \"int\", }],\n    defaultParams: [10]\n  });\n\n  addFuncDef({\n    name: 'offsetToZero',\n    category: categories.Transform,\n  });\n\n  addFuncDef({\n    name: 'transformNull',\n    category: categories.Transform,\n    params: [{ name: \"amount\", type: \"int\", }],\n    defaultParams: [0]\n  });\n\n  addFuncDef({\n    name: 'integral',\n    category: categories.Transform,\n  });\n\n  addFuncDef({\n    name: 'derivative',\n    category: categories.Transform,\n  });\n\n  addFuncDef({\n    name: 'nonNegativeDerivative',\n    category: categories.Transform,\n    params: [{ name: \"max value or 0\", type: \"int\", optional: true }],\n    defaultParams: ['']\n  });\n\n  addFuncDef({\n    name: 'timeShift',\n    category: categories.Transform,\n    params: [{ name: \"amount\", type: \"select\", options: ['1h', '6h', '12h', '1d', '2d', '7d', '14d', '30d'] }],\n    defaultParams: ['1d']\n  });\n\n  addFuncDef({\n    name: 'timeStack',\n    category: categories.Transform,\n    params: [\n      { name: \"timeShiftUnit\", type: \"select\", options: ['1h', '6h', '12h', '1d', '2d', '7d', '14d', '30d'] },\n      { name: \"timeShiftStart\", type: \"int\" },\n      { name: \"timeShiftEnd\", type: \"int\" }\n    ],\n    defaultParams: ['1d', 0, 7]\n  });\n\n  addFuncDef({\n    name: 'summarize',\n    category: categories.Transform,\n    params: [\n      { name: \"interval\", type: \"string\" },\n      { name: \"func\", type: \"select\", options: ['sum', 'avg', 'min', 'max', 'last'] },\n      { name: \"alignToFrom\", type: \"boolean\", optional: true, options: ['false', 'true'] },\n    ],\n    defaultParams: ['1h', 'sum', 'false']\n  });\n\n  addFuncDef({\n    name: 'smartSummarize',\n    category: categories.Transform,\n    params: [{ name: \"interval\", type: \"string\" }, { name: \"func\", type: \"select\", options: ['sum', 'avg', 'min', 'max', 'last'] }],\n    defaultParams: ['1h', 'sum']\n  });\n\n  addFuncDef({\n    name: 'absolute',\n    category: categories.Transform,\n  });\n\n  addFuncDef({\n    name: 'hitcount',\n    category: categories.Transform,\n    params: [{ name: \"interval\", type: \"string\" }],\n    defaultParams: ['10s']\n  });\n\n  addFuncDef({\n    name: 'log',\n    category: categories.Transform,\n    params: [{ name: \"base\", type: \"int\" }],\n    defaultParams: ['10']\n  });\n\n  addFuncDef({\n    name: 'averageAbove',\n    category: categories.Filter,\n    params: [{ name: \"n\", type: \"int\", }],\n    defaultParams: [25]\n  });\n\n  addFuncDef({\n    name: 'averageBelow',\n    category: categories.Filter,\n    params: [{ name: \"n\", type: \"int\", }],\n    defaultParams: [25]\n  });\n\n  addFuncDef({\n    name: 'currentAbove',\n    category: categories.Filter,\n    params: [{ name: \"n\", type: \"int\", }],\n    defaultParams: [25]\n  });\n\n  addFuncDef({\n    name: 'currentBelow',\n    category: categories.Filter,\n    params: [{ name: \"n\", type: \"int\", }],\n    defaultParams: [25]\n  });\n\n  addFuncDef({\n    name: 'maximumAbove',\n    category: categories.Filter,\n    params: [{ name: \"value\", type: \"int\" }],\n    defaultParams: [0]\n  });\n\n  addFuncDef({\n    name: 'maximumBelow',\n    category: categories.Filter,\n    params: [{ name: \"value\", type: \"int\" }],\n    defaultParams: [0]\n  });\n\n  addFuncDef({\n    name: 'minimumAbove',\n    category: categories.Filter,\n    params: [{ name: \"value\", type: \"int\" }],\n    defaultParams: [0]\n  });\n\n  addFuncDef({\n    name: 'minimumBelow',\n    category: categories.Filter,\n    params: [{ name: \"value\", type: \"int\" }],\n    defaultParams: [0]\n  });\n\n  addFuncDef({\n    name: 'limit',\n    category: categories.Filter,\n    params: [{ name: \"n\", type: \"int\" }],\n    defaultParams: [5]\n  });\n\n  addFuncDef({\n    name: 'mostDeviant',\n    category: categories.Filter,\n    params: [{ name: \"n\", type: \"int\" }],\n    defaultParams: [10]\n  });\n\n  addFuncDef({\n    name: \"exclude\",\n    category: categories.Filter,\n    params: [{ name: \"exclude\", type: 'string' }],\n    defaultParams: ['exclude']\n  });\n\n  addFuncDef({\n    name: 'highestCurrent',\n    category: categories.Filter,\n    params: [{ name: \"count\", type: \"int\" }],\n    defaultParams: [5]\n  });\n\n  addFuncDef({\n    name: 'highestMax',\n    category: categories.Filter,\n    params: [{ name: \"count\", type: \"int\" }],\n    defaultParams: [5]\n  });\n\n  addFuncDef({\n    name: 'lowestCurrent',\n    category: categories.Filter,\n    params: [{ name: \"count\", type: \"int\" }],\n    defaultParams: [5]\n  });\n\n  addFuncDef({\n    name: 'movingAverage',\n    category: categories.Filter,\n    params: [{ name: \"windowSize\", type: \"int_or_interval\", options: ['5', '7', '10', '5min', '10min', '30min', '1hour'] }],\n    defaultParams: [10]\n  });\n\n  addFuncDef({\n    name: 'weightedAverage',\n    category: categories.Filter,\n    params: [\n      { name: 'other', type: 'value_or_series', optional: true },\n      { name: \"node\", type: \"int\", options: [0,1,2,3,4,5,6,7,8,9,10,12] },\n    ],\n    defaultParams: ['#A', 4]\n  });\n\n  addFuncDef({\n    name: 'movingMedian',\n    category: categories.Filter,\n    params: [{ name: \"windowSize\", type: \"int_or_interval\", options: ['5', '7', '10', '5min', '10min', '30min', '1hour'] }],\n    defaultParams: ['5']\n  });\n\n  addFuncDef({\n    name: 'stdev',\n    category: categories.Filter,\n    params: [{ name: \"n\", type: \"int\" }, { name: \"tolerance\", type: \"int\" }],\n    defaultParams: [5,0.1]\n  });\n\n  addFuncDef({\n    name: 'highestAverage',\n    category: categories.Filter,\n    params: [{ name: \"count\", type: \"int\" }],\n    defaultParams: [5]\n  });\n\n  addFuncDef({\n    name: 'lowestAverage',\n    category: categories.Filter,\n    params: [{ name: \"count\", type: \"int\" }],\n    defaultParams: [5]\n  });\n\n  addFuncDef({\n    name: 'removeAbovePercentile',\n    category: categories.Filter,\n    params: [{ name: \"n\", type: \"int\" }],\n    defaultParams: [5]\n  });\n\n  addFuncDef({\n    name: 'removeAboveValue',\n    category: categories.Filter,\n    params: [{ name: \"n\", type: \"int\" }],\n    defaultParams: [5]\n  });\n\n  addFuncDef({\n    name: 'removeBelowPercentile',\n    category: categories.Filter,\n    params: [{ name: \"n\", type: \"int\" }],\n    defaultParams: [5]\n  });\n\n  addFuncDef({\n    name: 'removeBelowValue',\n    category: categories.Filter,\n    params: [{ name: \"n\", type: \"int\" }],\n    defaultParams: [5]\n  });\n\n  addFuncDef({\n    name: 'useSeriesAbove',\n    category: categories.Filter,\n    params: [\n      { name: \"value\", type: \"int\" },\n      { name: \"search\", type: \"string\" },\n      { name: \"replace\", type: \"string\" }\n    ],\n    defaultParams: [0, 'search', 'replace']\n  });\n\n  _.each(categories, function(funcList, catName) {\n    categories[catName] = _.sortBy(funcList, 'name');\n  });\n\n  function FuncInstance(funcDef, options) {\n    this.def = funcDef;\n    this.params = [];\n\n    if (options && options.withDefaultParams) {\n      this.params = funcDef.defaultParams.slice(0);\n    }\n\n    this.updateText();\n  }\n\n  FuncInstance.prototype.render = function(metricExp) {\n    var str = this.def.name + '(';\n    var parameters = _.map(this.params, function(value, index) {\n\n      var paramType = this.def.params[index].type;\n      if (paramType === 'int' || paramType === 'value_or_series' || paramType === 'boolean') {\n        return value;\n      }\n      else if (paramType === 'int_or_interval' && $.isNumeric(value)) {\n        return value;\n      }\n\n      return \"'\" + value + \"'\";\n\n    }, this);\n\n    if (metricExp) {\n      parameters.unshift(metricExp);\n    }\n\n    return str + parameters.join(', ') + ')';\n  };\n\n  FuncInstance.prototype._hasMultipleParamsInString = function(strValue, index) {\n    if (strValue.indexOf(',') === -1) {\n      return false;\n    }\n\n    return this.def.params[index + 1] && this.def.params[index + 1].optional;\n  };\n\n  FuncInstance.prototype.updateParam = function(strValue, index) {\n    // handle optional parameters\n    // if string contains ',' and next param is optional, split and update both\n    if (this._hasMultipleParamsInString(strValue, index)) {\n      _.each(strValue.split(','), function(partVal, idx) {\n        this.updateParam(partVal.trim(), idx);\n      }, this);\n      return;\n    }\n\n    if (strValue === '' && this.def.params[index].optional) {\n      this.params.splice(index, 1);\n    }\n    else {\n      this.params[index] = strValue;\n    }\n\n    this.updateText();\n  };\n\n  FuncInstance.prototype.updateText = function () {\n    if (this.params.length === 0) {\n      this.text = this.def.name + '()';\n      return;\n    }\n\n    var text = this.def.name + '(';\n    text += this.params.join(', ');\n    text += ')';\n    this.text = text;\n  };\n\n  return {\n    createFuncInstance: function(funcDef, options) {\n      if (_.isString(funcDef)) {\n        if (!index[funcDef]) {\n          throw { message: 'Method not found ' + name };\n        }\n        funcDef = index[funcDef];\n      }\n      return new FuncInstance(funcDef, options);\n    },\n\n    getFuncDef: function(name) {\n      return index[name];\n    },\n\n    getCategories: function() {\n      return categories;\n    }\n  };\n\n});\n","coverage":[1,null,null,null,null,null,null,1,1,null,null,null,null,null,null,null,1,78,78,null,78,78,null,78,78,null,null,1,null,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,1,null,null,null,null,1,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,1,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,null,null,null,null,1,null,null,null,null,1,null,null,null,null,1,null,null,null,null,1,null,null,null,null,1,null,null,null,null,null,null,null,1,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,1,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,1,5,null,null,1,37,37,null,37,6,null,null,37,null,null,1,14,14,null,14,14,10,null,4,1,null,null,3,null,null,null,14,13,null,null,14,null,null,1,10,8,null,null,2,null,null,1,null,null,10,2,4,null,2,null,null,8,1,null,null,7,null,null,8,null,null,1,62,31,31,null,null,31,31,31,31,null,null,1,null,37,32,0,null,32,null,37,null,null,null,4,null,null,null,1,null,null,null,null,null]},{"name":"public/app/plugins/datasource/graphite/datasource.js","source":"define([\n  'angular',\n  'lodash',\n  'jquery',\n  'config',\n  'kbn',\n  'moment',\n  './queryCtrl',\n  './funcEditor',\n  './addGraphiteFunc',\n],\nfunction (angular, _, $, config, kbn, moment) {\n  'use strict';\n\n  var module = angular.module('grafana.services');\n\n  module.factory('GraphiteDatasource', function($q, backendSrv, templateSrv) {\n\n    function GraphiteDatasource(datasource) {\n      this.basicAuth = datasource.basicAuth;\n      this.url = datasource.url;\n      this.name = datasource.name;\n      this.cacheTimeout = datasource.cacheTimeout;\n      this.withCredentials = datasource.withCredentials;\n      this.render_method = datasource.render_method || 'POST';\n    }\n\n    GraphiteDatasource.prototype.query = function(options) {\n      try {\n        var graphOptions = {\n          from: this.translateTime(options.range.from, 'round-down'),\n          until: this.translateTime(options.range.to, 'round-up'),\n          targets: options.targets,\n          format: options.format,\n          cacheTimeout: options.cacheTimeout || this.cacheTimeout,\n          maxDataPoints: options.maxDataPoints,\n        };\n\n        var params = this.buildGraphiteParams(graphOptions, options.scopedVars);\n\n        if (options.format === 'png') {\n          return $q.when(this.url + '/render' + '?' + params.join('&'));\n        }\n\n        var httpOptions = { method: this.render_method, url: '/render' };\n\n        if (httpOptions.method === 'GET') {\n          httpOptions.url = httpOptions.url + '?' + params.join('&');\n        }\n        else {\n          httpOptions.data = params.join('&');\n          httpOptions.headers = { 'Content-Type': 'application/x-www-form-urlencoded' };\n        }\n\n        return this.doGraphiteRequest(httpOptions).then(this.convertDataPointsToMs);\n      }\n      catch(err) {\n        return $q.reject(err);\n      }\n    };\n\n    GraphiteDatasource.prototype.convertDataPointsToMs = function(result) {\n      if (!result || !result.data) { return []; }\n      for (var i = 0; i < result.data.length; i++) {\n        var series = result.data[i];\n        for (var y = 0; y < series.datapoints.length; y++) {\n          series.datapoints[y][1] *= 1000;\n        }\n      }\n      return result;\n    };\n\n    GraphiteDatasource.prototype.annotationQuery = function(annotation, rangeUnparsed) {\n      // Graphite metric as annotation\n      if (annotation.target) {\n        var target = templateSrv.replace(annotation.target);\n        var graphiteQuery = {\n          range: rangeUnparsed,\n          targets: [{ target: target }],\n          format: 'json',\n          maxDataPoints: 100\n        };\n\n        return this.query(graphiteQuery)\n          .then(function(result) {\n            var list = [];\n\n            for (var i = 0; i < result.data.length; i++) {\n              var target = result.data[i];\n\n              for (var y = 0; y < target.datapoints.length; y++) {\n                var datapoint = target.datapoints[y];\n                if (!datapoint[0]) { continue; }\n\n                list.push({\n                  annotation: annotation,\n                  time: datapoint[1],\n                  title: target.target\n                });\n              }\n            }\n\n            return list;\n          });\n      }\n      // Graphite event as annotation\n      else {\n        var tags = templateSrv.replace(annotation.tags);\n        return this.events({ range: rangeUnparsed, tags: tags })\n          .then(function(results) {\n            var list = [];\n            for (var i = 0; i < results.data.length; i++) {\n              var e = results.data[i];\n              list.push({\n                annotation: annotation,\n                time: e.when * 1000,\n                title: e.what,\n                tags: e.tags,\n                text: e.data\n              });\n            }\n            return list;\n          });\n      }\n    };\n\n    GraphiteDatasource.prototype.events = function(options) {\n      try {\n        var tags = '';\n        if (options.tags) {\n          tags = '&tags=' + options.tags;\n        }\n\n        return this.doGraphiteRequest({\n          method: 'GET',\n          url: '/events/get_data?from=' + this.translateTime(options.range.from) + '&until=' + this.translateTime(options.range.to) + tags,\n        });\n      }\n      catch(err) {\n        return $q.reject(err);\n      }\n    };\n\n    GraphiteDatasource.prototype.translateTime = function(date, rounding) {\n      if (_.isString(date)) {\n        if (date === 'now') {\n          return 'now';\n        }\n        else if (date.indexOf('now') >= 0) {\n          date = date.substring(3);\n          date = date.replace('m', 'min');\n          date = date.replace('M', 'mon');\n          return date;\n        }\n        date = kbn.parseDate(date);\n      }\n\n      date = moment.utc(date);\n\n      if (rounding === 'round-up') {\n        if (date.get('s')) {\n          date.add(1, 'm');\n        }\n      }\n      else if (rounding === 'round-down') {\n        // graphite' s from filter is exclusive\n        // here we step back one minute in order\n        // to guarantee that we get all the data that\n        // exists for the specified range\n        if (date.get('s')) {\n          date.subtract(1, 'm');\n        }\n      }\n\n      return date.unix();\n    };\n\n    GraphiteDatasource.prototype.metricFindQuery = function(query) {\n      var interpolated;\n      try {\n        interpolated = encodeURIComponent(templateSrv.replace(query));\n      }\n      catch(err) {\n        return $q.reject(err);\n      }\n\n      return this.doGraphiteRequest({method: 'GET', url: '/metrics/find/?query=' + interpolated })\n        .then(function(results) {\n          return _.map(results.data, function(metric) {\n            return {\n              text: metric.text,\n              expandable: metric.expandable ? true : false\n            };\n          });\n        });\n    };\n\n    GraphiteDatasource.prototype.listDashboards = function(query) {\n      return this.doGraphiteRequest({ method: 'GET',  url: '/dashboard/find/', params: {query: query || ''} })\n        .then(function(results) {\n          return results.data.dashboards;\n        });\n    };\n\n    GraphiteDatasource.prototype.loadDashboard = function(dashName) {\n      return this.doGraphiteRequest({method: 'GET', url: '/dashboard/load/' + encodeURIComponent(dashName) });\n    };\n\n    GraphiteDatasource.prototype.doGraphiteRequest = function(options) {\n      if (this.basicAuth || this.withCredentials) {\n        options.withCredentials = true;\n      }\n      if (this.basicAuth) {\n        options.headers = options.headers || {};\n        options.headers.Authorization = this.basicAuth;\n      }\n\n      options.url = this.url + options.url;\n      options.inspect = { type: 'graphite' };\n\n      return backendSrv.datasourceRequest(options);\n    };\n\n    GraphiteDatasource.prototype._seriesRefLetters = [\n      '#A', '#B', '#C', '#D',\n      '#E', '#F', '#G', '#H',\n      '#I', '#J', '#K', '#L',\n      '#M', '#N', '#O', '#P',\n      '#Q', '#R', '#S', '#T',\n      '#U', '#V', '#W', '#X',\n      '#Y', '#Z'\n    ];\n\n    GraphiteDatasource.prototype.buildGraphiteParams = function(options, scopedVars) {\n      var graphite_options = ['from', 'until', 'rawData', 'format', 'maxDataPoints', 'cacheTimeout'];\n      var clean_options = [], targets = {};\n      var target, targetValue, i;\n      var regex = /(\\#[A-Z])/g;\n      var intervalFormatFixRegex = /'(\\d+)m'/gi;\n\n      if (options.format !== 'png') {\n        options['format'] = 'json';\n      }\n\n      function fixIntervalFormat(match) {\n        return match.replace('m', 'min').replace('M', 'mon');\n      }\n\n      for (i = 0; i < options.targets.length; i++) {\n        target = options.targets[i];\n        if (!target.target) {\n          continue;\n        }\n\n        targetValue = templateSrv.replace(target.target, scopedVars);\n        targetValue = targetValue.replace(intervalFormatFixRegex, fixIntervalFormat);\n        targets[this._seriesRefLetters[i]] = targetValue;\n      }\n\n      function nestedSeriesRegexReplacer(match) {\n        return targets[match];\n      }\n\n      for (i = 0; i < options.targets.length; i++) {\n        target = options.targets[i];\n        if (!target.target || target.hide) {\n          continue;\n        }\n\n        targetValue = targets[this._seriesRefLetters[i]];\n        targetValue = targetValue.replace(regex, nestedSeriesRegexReplacer);\n        targets[this._seriesRefLetters[i]] = targetValue;\n\n        clean_options.push(\"target=\" + encodeURIComponent(targetValue));\n      }\n\n      _.each(options, function (value, key) {\n        if ($.inArray(key, graphite_options) === -1) { return; }\n        if (value) {\n          clean_options.push(key + \"=\" + encodeURIComponent(value));\n        }\n      });\n\n      return clean_options;\n    };\n\n    return GraphiteDatasource;\n\n  });\n\n});\n","coverage":[1,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,1,11,11,11,11,11,11,null,null,11,5,5,null,null,null,null,null,null,null,null,5,null,5,0,null,null,5,null,5,0,null,null,5,5,null,null,5,null,null,0,null,null,null,11,5,5,5,5,10,null,null,5,null,null,11,null,0,0,0,null,null,null,null,null,null,0,null,0,null,0,0,null,0,0,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,0,0,null,0,0,0,0,null,null,null,null,null,null,null,0,null,null,null,null,11,0,0,0,0,null,null,0,null,null,null,null,null,0,null,null,null,11,10,10,5,null,5,5,5,5,5,null,0,null,null,0,null,0,0,0,null,null,0,null,null,null,null,0,0,null,null,null,0,null,null,11,0,0,0,null,null,0,null,null,0,null,0,0,null,null,null,null,null,null,null,11,0,null,0,null,null,null,11,0,null,null,11,5,0,null,5,0,0,null,null,5,5,null,5,null,null,11,null,null,null,null,null,null,null,null,null,11,11,11,11,11,11,null,11,11,null,null,1,2,null,null,11,22,22,1,null,null,21,21,21,null,null,1,5,null,null,11,22,22,1,null,null,21,21,21,null,21,null,null,11,42,31,26,null,null,null,11,null,null,11,null,null,null,null,null]},{"name":"public/app/plugins/datasource/influxdb_08/queryBuilder.js","source":"define([\n],\nfunction () {\n  'use strict';\n\n  function InfluxQueryBuilder(target) {\n    this.target = target;\n  }\n\n  var p = InfluxQueryBuilder.prototype;\n\n  p.build = function() {\n    return this.target.rawQuery ? this._modifyRawQuery() : this._buildQuery();\n  };\n\n  p._buildQuery = function() {\n    var target = this.target;\n    var query = 'select ';\n    var seriesName = target.series;\n\n    if(!seriesName.match('^/.*/') && !seriesName.match(/^merge\\(.*\\)/)) {\n      seriesName = '\"' + seriesName+ '\"';\n    }\n\n    if (target.groupby_field) {\n      query += target.groupby_field + ', ';\n    }\n\n    query +=  target.function + '(' + target.column + ')';\n    query += ' from ' + seriesName + ' where $timeFilter';\n\n    if (target.condition) {\n      query += ' and ' + target.condition;\n    }\n\n    query += ' group by time($interval)';\n\n    if (target.groupby_field) {\n      query += ', ' + target.groupby_field;\n      this.groupByField = target.groupby_field;\n    }\n\n    if (target.fill) {\n      query += ' fill(' + target.fill + ')';\n    }\n\n    query += \" order asc\";\n    target.query = query;\n\n    return query;\n  };\n\n  p._modifyRawQuery = function () {\n    var query = this.target.query.replace(\";\", \"\");\n\n    var queryElements = query.split(\" \");\n    var lowerCaseQueryElements = query.toLowerCase().split(\" \");\n\n    if (lowerCaseQueryElements[1].indexOf(',') !== -1) {\n      this.groupByField = lowerCaseQueryElements[1].replace(',', '');\n    }\n\n    return queryElements.join(\" \");\n  };\n\n  return InfluxQueryBuilder;\n});\n","coverage":[1,null,null,null,null,1,7,null,null,1,null,1,7,null,null,1,6,6,6,null,6,5,null,null,6,1,null,null,6,6,null,6,1,null,null,6,null,6,1,1,null,null,6,1,null,null,6,6,null,6,null,null,1,1,null,1,1,null,1,0,null,null,1,null,null,1,null,null]},{"name":"public/app/plugins/datasource/graphite/queryCtrl.js","source":"define([\n  'angular',\n  'lodash',\n  'config',\n  './gfunc',\n  './parser'\n],\nfunction (angular, _, config, gfunc, Parser) {\n  'use strict';\n\n  var module = angular.module('grafana.controllers');\n  var targetLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n  module.controller('GraphiteQueryCtrl', function($scope, $sce, templateSrv) {\n\n    $scope.init = function() {\n      $scope.target.target = $scope.target.target || '';\n      $scope.targetLetters = targetLetters;\n\n      parseTarget();\n    };\n\n    // The way parsing and the target editor works needs\n    // to be rewritten to handle functions that take multiple series\n    function parseTarget() {\n      $scope.functions = [];\n      $scope.segments = [];\n      $scope.showTextEditor = false;\n\n      delete $scope.parserError;\n\n      var parser = new Parser($scope.target.target);\n      var astNode = parser.getAst();\n      if (astNode === null) {\n        checkOtherSegments(0);\n        return;\n      }\n\n      if (astNode.type === 'error') {\n        $scope.parserError = astNode.message + \" at position: \" + astNode.pos;\n        $scope.showTextEditor = true;\n        return;\n      }\n\n      try {\n        parseTargeRecursive(astNode);\n      }\n      catch (err) {\n        console.log('error parsing target:', err.message);\n        $scope.parserError = err.message;\n        $scope.showTextEditor = true;\n      }\n\n      checkOtherSegments($scope.segments.length - 1);\n    }\n\n    function addFunctionParameter(func, value, index, shiftBack) {\n      if (shiftBack) {\n        index = Math.max(index - 1, 0);\n      }\n      func.params[index] = value;\n    }\n\n    function parseTargeRecursive(astNode, func, index) {\n      if (astNode === null) {\n        return null;\n      }\n\n      switch(astNode.type) {\n      case 'function':\n        var innerFunc = gfunc.createFuncInstance(astNode.name, { withDefaultParams: false });\n\n        _.each(astNode.params, function(param, index) {\n          parseTargeRecursive(param, innerFunc, index);\n        });\n\n        innerFunc.updateText();\n        $scope.functions.push(innerFunc);\n        break;\n\n      case 'series-ref':\n        addFunctionParameter(func, astNode.value, index, $scope.segments.length > 0);\n        break;\n      case 'string':\n      case 'number':\n        if ((index-1) >= func.def.params.length) {\n          throw { message: 'invalid number of parameters to method ' + func.def.name };\n        }\n        addFunctionParameter(func, astNode.value, index, true);\n        break;\n      case 'metric':\n        if ($scope.segments.length > 0) {\n          if (astNode.segments.length !== 1) {\n            throw { message: 'Multiple metric params not supported, use text editor.' };\n          }\n          addFunctionParameter(func, astNode.segments[0].value, index, true);\n          break;\n        }\n\n        $scope.segments = _.map(astNode.segments, function(segment) {\n          return new MetricSegment(segment);\n        });\n      }\n    }\n\n    function getSegmentPathUpTo(index) {\n      var arr = $scope.segments.slice(0, index);\n\n      return _.reduce(arr, function(result, segment) {\n        return result ? (result + \".\" + segment.value) : segment.value;\n      }, \"\");\n    }\n\n    function checkOtherSegments(fromIndex) {\n      if (fromIndex === 0) {\n        $scope.segments.push(MetricSegment.newSelectMetric());\n        return;\n      }\n\n      var path = getSegmentPathUpTo(fromIndex + 1);\n      return $scope.datasource.metricFindQuery(path)\n        .then(function(segments) {\n          if (segments.length === 0) {\n            if (path !== '') {\n              $scope.segments = $scope.segments.splice(0, fromIndex);\n              $scope.segments.push(MetricSegment.newSelectMetric());\n            }\n            return;\n          }\n          if (segments[0].expandable) {\n            if ($scope.segments.length === fromIndex) {\n              $scope.segments.push(MetricSegment.newSelectMetric());\n            }\n            else {\n              return checkOtherSegments(fromIndex + 1);\n            }\n          }\n        })\n        .then(null, function(err) {\n          $scope.parserError = err.message || 'Failed to issue metric query';\n        });\n    }\n\n    function setSegmentFocus(segmentIndex) {\n      _.each($scope.segments, function(segment, index) {\n        segment.focus = segmentIndex === index;\n      });\n    }\n\n    function wrapFunction(target, func) {\n      return func.render(target);\n    }\n\n    $scope.getAltSegments = function (index) {\n      $scope.altSegments = [];\n\n      var query = index === 0 ?  '*' : getSegmentPathUpTo(index) + '.*';\n\n      return $scope.datasource.metricFindQuery(query)\n        .then(function(segments) {\n          $scope.altSegments = _.map(segments, function(segment) {\n            return new MetricSegment({ value: segment.text, expandable: segment.expandable });\n          });\n\n          if ($scope.altSegments.length === 0) {\n            return;\n          }\n\n          // add template variables\n          _.each(templateSrv.variables, function(variable) {\n            $scope.altSegments.unshift(new MetricSegment({\n              type: 'template',\n              value: '$' + variable.name,\n              expandable: true,\n            }));\n          });\n\n          // add wildcard option\n          $scope.altSegments.unshift(new MetricSegment('*'));\n        })\n        .then(null, function(err) {\n          $scope.parserError = err.message || 'Failed to issue metric query';\n        });\n    };\n\n    $scope.segmentValueChanged = function (segment, segmentIndex) {\n      delete $scope.parserError;\n\n      if ($scope.functions.length > 0 && $scope.functions[0].def.fake) {\n        $scope.functions = [];\n      }\n\n      if (segment.expandable) {\n        return checkOtherSegments(segmentIndex + 1)\n          .then(function () {\n            setSegmentFocus(segmentIndex + 1);\n            $scope.targetChanged();\n          });\n      }\n      else {\n        $scope.segments = $scope.segments.splice(0, segmentIndex + 1);\n      }\n\n      setSegmentFocus(segmentIndex + 1);\n      $scope.targetChanged();\n    };\n\n    $scope.targetTextChanged = function() {\n      parseTarget();\n      $scope.get_data();\n    };\n\n    $scope.targetChanged = function() {\n      if ($scope.parserError) {\n        return;\n      }\n\n      var oldTarget = $scope.target.target;\n\n      var target = getSegmentPathUpTo($scope.segments.length);\n      $scope.target.target = _.reduce($scope.functions, wrapFunction, target);\n\n      if ($scope.target.target !== oldTarget) {\n        $scope.$parent.get_data();\n      }\n    };\n\n    $scope.removeFunction = function(func) {\n      $scope.functions = _.without($scope.functions, func);\n      $scope.targetChanged();\n    };\n\n    $scope.addFunction = function(funcDef) {\n      var newFunc = gfunc.createFuncInstance(funcDef, { withDefaultParams: true });\n      newFunc.added = true;\n      $scope.functions.push(newFunc);\n\n      $scope.moveAliasFuncLast();\n      $scope.smartlyHandleNewAliasByNode(newFunc);\n\n      if ($scope.segments.length === 1 && $scope.segments[0].fake) {\n        $scope.segments = [];\n      }\n\n      if (!newFunc.params.length && newFunc.added) {\n        $scope.targetChanged();\n      }\n    };\n\n    $scope.moveAliasFuncLast = function() {\n      var aliasFunc = _.find($scope.functions, function(func) {\n        return func.def.name === 'alias' ||\n               func.def.name === 'aliasByNode' ||\n               func.def.name === 'aliasByMetric';\n      });\n\n      if (aliasFunc) {\n        $scope.functions = _.without($scope.functions, aliasFunc);\n        $scope.functions.push(aliasFunc);\n      }\n    };\n\n    $scope.smartlyHandleNewAliasByNode = function(func) {\n      if (func.def.name !== 'aliasByNode') {\n        return;\n      }\n      for(var i = 0; i < $scope.segments.length; i++) {\n        if ($scope.segments[i].value.indexOf('*') >= 0)  {\n          func.params[0] = i;\n          func.added = false;\n          $scope.targetChanged();\n          return;\n        }\n      }\n    };\n\n    $scope.toggleMetricOptions = function() {\n      $scope.panel.metricOptionsEnabled = !$scope.panel.metricOptionsEnabled;\n      if (!$scope.panel.metricOptionsEnabled) {\n        delete $scope.panel.cacheTimeout;\n      }\n    };\n\n    $scope.moveMetricQuery = function(fromIndex, toIndex) {\n      _.move($scope.panel.targets, fromIndex, toIndex);\n    };\n\n    $scope.duplicate = function() {\n      var clone = angular.copy($scope.target);\n      $scope.panel.targets.push(clone);\n    };\n\n    function MetricSegment(options) {\n      if (options === '*' || options.value === '*') {\n        this.value = '*';\n        this.html = $sce.trustAsHtml('<i class=\"fa fa-asterisk\"><i>');\n        this.expandable = true;\n        return;\n      }\n\n      this.fake = options.fake;\n      this.value = options.value;\n      this.type = options.type;\n      this.expandable = options.expandable;\n      this.html = $sce.trustAsHtml(templateSrv.highlightVariablesAsHtml(this.value));\n    }\n\n    MetricSegment.newSelectMetric = function() {\n      return new MetricSegment({value: 'select metric', fake: true});\n    };\n\n  });\n\n  module.directive('focusMe', function($timeout, $parse) {\n    return {\n      //scope: true,   // optionally create a child scope\n      link: function(scope, element, attrs) {\n        var model = $parse(attrs.focusMe);\n        scope.$watch(model, function(value) {\n          if(value === true) {\n            $timeout(function() {\n              element[0].focus();\n            });\n          }\n        });\n      }\n    };\n  });\n\n});\n","coverage":[1,null,null,null,null,null,null,null,null,null,1,1,null,1,null,16,16,16,null,16,null,null,null,null,1,16,16,16,null,16,null,16,16,16,1,1,null,null,15,0,0,0,null,null,15,15,null,null,0,0,0,null,null,15,null,null,1,18,14,null,18,null,null,1,47,0,null,null,47,null,16,null,16,32,null,null,16,16,16,null,null,6,6,null,null,10,0,null,10,10,null,15,2,0,null,2,2,null,null,13,39,null,null,null,null,1,21,null,21,58,null,null,null,1,16,1,1,null,null,15,15,null,15,10,8,8,null,10,null,5,0,0,null,null,0,null,null,null,null,0,null,null,null,1,0,0,null,null,null,1,7,null,null,16,1,null,1,null,1,null,1,0,null,null,1,1,null,null,null,0,0,null,null,null,null,null,null,null,0,null,null,0,null,null,null,16,0,null,0,0,null,null,0,0,null,0,0,null,null,null,0,null,null,0,0,null,null,16,0,0,null,null,16,5,0,null,null,5,null,5,5,null,5,5,null,null,null,16,0,0,null,null,16,4,4,4,null,4,4,null,4,1,null,null,4,0,null,null,null,16,4,4,null,null,null,null,4,3,3,null,null,null,16,4,1,null,3,9,3,3,3,3,null,null,null,null,16,0,0,0,null,null,null,16,0,null,null,16,0,0,null,null,1,48,8,8,8,8,null,null,40,40,40,40,40,null,null,16,9,null,null,null,null,1,0,null,null,0,0,0,0,0,null,null,null,null,null,null,null,null,null]},{"name":"public/app/plugins/datasource/influxdb_08/influxSeries.js","source":"define([\n  'lodash',\n],\nfunction (_) {\n  'use strict';\n\n  function InfluxSeries(options) {\n    this.seriesList = options.seriesList;\n    this.alias = options.alias;\n    this.groupByField = options.groupByField;\n    this.annotation = options.annotation;\n  }\n\n  var p = InfluxSeries.prototype;\n\n  p.getTimeSeries = function() {\n    var output = [];\n    var self = this;\n    var i;\n\n    _.each(self.seriesList, function(series) {\n      var seriesName;\n      var timeCol = series.columns.indexOf('time');\n      var valueCol = 1;\n      var groupByCol = -1;\n\n      if (self.groupByField) {\n        groupByCol = series.columns.indexOf(self.groupByField);\n      }\n\n      // find value column\n      _.each(series.columns, function(column, index) {\n        if (column !== 'time' && column !== 'sequence_number' && column !== self.groupByField) {\n          valueCol = index;\n        }\n      });\n\n      var groups = {};\n\n      if (self.groupByField) {\n        groups = _.groupBy(series.points, function (point) {\n          return point[groupByCol];\n        });\n      }\n      else {\n        groups[series.columns[valueCol]] = series.points;\n      }\n\n      _.each(groups, function(groupPoints, key) {\n        var datapoints = [];\n        for (i = 0; i < groupPoints.length; i++) {\n          var metricValue = isNaN(groupPoints[i][valueCol]) ? null : groupPoints[i][valueCol];\n          datapoints[i] = [metricValue, groupPoints[i][timeCol]];\n        }\n\n        seriesName = series.name + '.' + key;\n\n        if (self.alias) {\n          seriesName = self.createNameForSeries(series.name, key);\n        }\n\n        output.push({ target: seriesName, datapoints: datapoints });\n      });\n    });\n\n    return output;\n  };\n\n  p.getAnnotations = function () {\n    var list = [];\n    var self = this;\n\n    _.each(this.seriesList, function (series) {\n      var titleCol = null;\n      var timeCol = null;\n      var tagsCol = null;\n      var textCol = null;\n\n      _.each(series.columns, function(column, index) {\n        if (column === 'time') { timeCol = index; return; }\n        if (column === 'sequence_number') { return; }\n        if (!titleCol) { titleCol = index; }\n        if (column === self.annotation.titleColumn) { titleCol = index; return; }\n        if (column === self.annotation.tagsColumn) { tagsCol = index; return; }\n        if (column === self.annotation.textColumn) { textCol = index; return; }\n      });\n\n      _.each(series.points, function (point) {\n        var data = {\n          annotation: self.annotation,\n          time: point[timeCol],\n          title: point[titleCol],\n          tags: point[tagsCol],\n          text: point[textCol]\n        };\n\n        if (tagsCol) {\n          data.tags = point[tagsCol];\n        }\n\n        list.push(data);\n      });\n    });\n\n    return list;\n  };\n\n  p.createNameForSeries = function(seriesName, groupByColValue) {\n    var regex = /\\$(\\w+)/g;\n    var segments = seriesName.split('.');\n\n    return this.alias.replace(regex, function(match, group) {\n      if (group === 's') {\n        return seriesName;\n      }\n      else if (group === 'g') {\n        return groupByColValue;\n      }\n      var index = parseInt(group);\n      if (_.isNumber(index) && index < segments.length) {\n        return segments[index];\n      }\n      return match;\n    });\n\n  };\n\n  return InfluxSeries;\n});\n","coverage":[1,null,null,null,null,null,1,12,12,12,12,null,null,1,null,1,9,9,9,null,9,9,9,9,9,null,9,2,null,null,null,9,27,11,null,null,null,9,null,9,2,5,null,null,null,7,null,null,9,10,10,17,17,null,null,10,null,10,4,null,null,10,null,null,null,9,null,null,1,3,3,null,3,2,2,2,2,null,2,8,6,4,4,3,2,null,null,2,3,null,null,null,null,null,null,null,3,2,null,null,3,null,null,null,3,null,null,1,4,4,null,4,6,1,null,5,1,null,4,4,4,null,0,null,null,null,null,1,null,null]},{"name":"public/app/components/timeSeries.js","source":"define([\n  'lodash',\n  'kbn'\n],\nfunction (_, kbn) {\n  'use strict';\n\n  function TimeSeries(opts) {\n    this.datapoints = opts.datapoints;\n    this.label = opts.alias;\n    this.id = opts.alias;\n    this.alias = opts.alias;\n    this.color = opts.color;\n    this.valueFormater = kbn.valueFormats.none;\n    this.stats = {};\n  }\n\n  function matchSeriesOverride(aliasOrRegex, seriesAlias) {\n    if (!aliasOrRegex) { return false; }\n\n    if (aliasOrRegex[0] === '/') {\n      var regex = kbn.stringToJsRegex(aliasOrRegex);\n      return seriesAlias.match(regex) != null;\n    }\n\n    return aliasOrRegex === seriesAlias;\n  }\n\n  function translateFillOption(fill) {\n    return fill === 0 ? 0.001 : fill/10;\n  }\n\n  TimeSeries.prototype.applySeriesOverrides = function(overrides) {\n    this.lines = {};\n    this.points = {};\n    this.bars = {};\n    this.yaxis = 1;\n    this.zindex = 0;\n    delete this.stack;\n\n    for (var i = 0; i < overrides.length; i++) {\n      var override = overrides[i];\n      if (!matchSeriesOverride(override.alias, this.alias)) {\n        continue;\n      }\n      if (override.lines !== void 0) { this.lines.show = override.lines; }\n      if (override.points !== void 0) { this.points.show = override.points; }\n      if (override.bars !== void 0) { this.bars.show = override.bars; }\n      if (override.fill !== void 0) { this.lines.fill = translateFillOption(override.fill); }\n      if (override.stack !== void 0) { this.stack = override.stack; }\n      if (override.linewidth !== void 0) { this.lines.lineWidth = override.linewidth; }\n      if (override.pointradius !== void 0) { this.points.radius = override.pointradius; }\n      if (override.steppedLine !== void 0) { this.lines.steps = override.steppedLine; }\n      if (override.zindex !== void 0) { this.zindex = override.zindex; }\n      if (override.fillBelowTo !== void 0) { this.fillBelowTo = override.fillBelowTo; }\n\n      if (override.yaxis !== void 0) {\n        this.yaxis = override.yaxis;\n      }\n    }\n  };\n\n  TimeSeries.prototype.getFlotPairs = function (fillStyle) {\n    var result = [];\n\n    this.stats.total = 0;\n    this.stats.max = -Number.MAX_VALUE;\n    this.stats.min = Number.MAX_VALUE;\n    this.stats.avg = null;\n    this.stats.current = null;\n    this.allIsNull = true;\n\n    var ignoreNulls = fillStyle === 'connected';\n    var nullAsZero = fillStyle === 'null as zero';\n    var currentTime;\n    var currentValue;\n\n    for (var i = 0; i < this.datapoints.length; i++) {\n      currentValue = this.datapoints[i][0];\n      currentTime = this.datapoints[i][1];\n\n      if (currentValue === null) {\n        if (ignoreNulls) { continue; }\n        if (nullAsZero) {\n          currentValue = 0;\n        }\n      }\n\n      if (currentValue !== null) {\n        if (_.isNumber(currentValue)) {\n          this.stats.total += currentValue;\n          this.allIsNull = false;\n        }\n\n        if (currentValue > this.stats.max) {\n          this.stats.max = currentValue;\n        }\n\n        if (currentValue < this.stats.min) {\n          this.stats.min = currentValue;\n        }\n      }\n\n      result.push([currentTime, currentValue]);\n    }\n\n    if (this.datapoints.length >= 2) {\n      this.stats.timeStep = this.datapoints[1][1] - this.datapoints[0][1];\n    }\n\n    if (this.stats.max === -Number.MAX_VALUE) { this.stats.max = null; }\n    if (this.stats.min === Number.MAX_VALUE) { this.stats.min = null; }\n\n    if (result.length) {\n      this.stats.avg = (this.stats.total / result.length);\n      this.stats.current = result[result.length-1][1];\n      if (this.stats.current === null && result.length > 1) {\n        this.stats.current = result[result.length-2][1];\n      }\n    }\n\n    return result;\n  };\n\n  TimeSeries.prototype.updateLegendValues = function(formater, decimals, scaledDecimals) {\n    this.valueFormater = formater;\n    this.decimals = decimals;\n    this.scaledDecimals = scaledDecimals;\n  };\n\n  TimeSeries.prototype.formatValue = function(value) {\n    return this.valueFormater(value, this.decimals, this.scaledDecimals);\n  };\n\n  return TimeSeries;\n\n});\n","coverage":[1,null,null,null,null,null,null,1,33,33,33,33,33,33,33,null,null,1,12,null,12,1,1,null,null,11,null,null,1,2,null,null,1,26,26,26,26,26,26,null,26,12,12,2,null,10,10,10,10,10,10,10,10,10,10,null,10,2,null,null,null,null,1,22,null,22,22,22,22,22,22,null,22,22,22,22,null,22,48,48,null,48,3,2,1,null,null,null,47,46,46,46,null,null,46,43,null,null,46,23,null,null,null,47,null,null,22,22,null,null,22,22,null,22,22,22,22,1,null,null,null,22,null,null,1,0,0,0,null,null,1,0,null,null,1,null,null,null]},{"name":"public/app/features/dashboard/rowCtrl.js","source":"define([\n  'angular',\n  'app',\n  'lodash',\n  'config'\n],\nfunction (angular, app, _, config) {\n  'use strict';\n\n  var module = angular.module('grafana.controllers');\n\n  module.controller('RowCtrl', function($scope, $rootScope, $timeout) {\n    var _d = {\n      title: \"Row\",\n      height: \"150px\",\n      collapse: false,\n      editable: true,\n      panels: [],\n    };\n\n    _.defaults($scope.row,_d);\n\n    $scope.init = function() {\n      $scope.editor = {index: 0};\n      $scope.reset_panel();\n    };\n\n    $scope.togglePanelMenu = function(posX) {\n      $scope.showPanelMenu = !$scope.showPanelMenu;\n      $scope.panelMenuPos = posX;\n    };\n\n    $scope.toggle_row = function(row) {\n      row.collapse = row.collapse ? false : true;\n      if (!row.collapse) {\n        $timeout(function() {\n          $scope.$broadcast('render');\n        });\n      }\n    };\n\n    $scope.add_panel = function(panel) {\n      $scope.dashboard.add_panel(panel, $scope.row);\n    };\n\n    $scope.delete_row = function() {\n      $scope.appEvent('confirm-modal', {\n        title: 'Are you sure you want to delete this row?',\n        icon: 'fa-trash',\n        yesText: 'delete',\n        onConfirm: function() {\n          $scope.dashboard.rows = _.without($scope.dashboard.rows, $scope.row);\n        }\n      });\n    };\n\n    $scope.move_row = function(direction) {\n      var rowsList = $scope.dashboard.rows;\n      var rowIndex = _.indexOf(rowsList, $scope.row);\n      var newIndex = rowIndex + direction;\n      if (newIndex >= 0 && newIndex <= (rowsList.length - 1)) {\n        _.move(rowsList, rowIndex, rowIndex + direction);\n      }\n    };\n\n    $scope.add_panel_default = function(type) {\n      $scope.reset_panel(type);\n      $scope.add_panel($scope.panel);\n\n      $timeout(function() {\n        $scope.$broadcast('render');\n      });\n    };\n\n    $scope.set_height = function(height) {\n      $scope.row.height = height;\n      $scope.$broadcast('render');\n    };\n\n    $scope.removePanel = function(panel) {\n      $scope.appEvent('confirm-modal', {\n        title: 'Are you sure you want to remove this panel?',\n        icon: 'fa-trash',\n        yesText: 'Delete',\n        onConfirm: function() {\n          $scope.row.panels = _.without($scope.row.panels, panel);\n        }\n      });\n    };\n\n    $scope.updatePanelSpan = function(panel, span) {\n      panel.span = Math.min(Math.max(panel.span + span, 1), 12);\n    };\n\n    $scope.replacePanel = function(newPanel, oldPanel) {\n      var row = $scope.row;\n      var index = _.indexOf(row.panels, oldPanel);\n      row.panels.splice(index, 1);\n\n      // adding it back needs to be done in next digest\n      $timeout(function() {\n        newPanel.id = oldPanel.id;\n        newPanel.span = oldPanel.span;\n        row.panels.splice(index, 0, newPanel);\n      });\n    };\n\n    $scope.reset_panel = function(type) {\n      var defaultSpan = 12;\n      var _as = 12 - $scope.dashboard.rowSpan($scope.row);\n\n      $scope.panel = {\n        title: config.new_panel_title,\n        error: false,\n        span: _as < defaultSpan && _as > 0 ? _as : defaultSpan,\n        editable: true,\n        type: type\n      };\n\n      function fixRowHeight(height) {\n        if (!height) {\n          return '200px';\n        }\n        if (!_.isString(height)) {\n          return height + 'px';\n        }\n        return height;\n      }\n\n      $scope.row.height = fixRowHeight($scope.row.height);\n    };\n\n    $scope.init();\n\n  });\n\n  module.directive('rowHeight', function() {\n    return function(scope, element) {\n      scope.$watchGroup(['row.collapse', 'row.height'], function() {\n        element[0].style.minHeight = scope.row.collapse ? '5px' : scope.row.height;\n      });\n    };\n  });\n\n  module.directive('panelWidth', function() {\n    return function(scope, element) {\n      function updateWidth() {\n        element[0].style.width = ((scope.panel.span / 1.2) * 10) + '%';\n      }\n\n      scope.$watch('panel.span', updateWidth);\n    };\n  });\n\n  module.directive('panelDropZone', function() {\n    return function(scope, element) {\n      scope.$on(\"ANGULAR_DRAG_START\", function() {\n        var dropZoneSpan = 12 - scope.dashboard.rowSpan(scope.row);\n\n        if (dropZoneSpan > 0) {\n          element.find('.panel-container').css('height', scope.row.height);\n          element[0].style.width = ((dropZoneSpan / 1.2) * 10) + '%';\n          element.show();\n        }\n      });\n\n      scope.$on(\"ANGULAR_DRAG_END\", function() {\n        element.hide();\n      });\n    };\n  });\n\n});\n","coverage":[1,null,null,null,null,null,null,null,null,1,null,1,0,null,null,null,null,null,null,null,0,null,0,0,0,null,null,0,0,0,null,null,0,0,0,0,0,null,null,null,null,0,0,null,null,0,0,null,null,null,null,0,null,null,null,null,0,0,0,0,0,0,null,null,null,0,0,0,null,0,0,null,null,null,0,0,0,null,null,0,0,null,null,null,null,0,null,null,null,null,0,0,null,null,0,0,0,0,null,null,0,0,0,0,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,1,0,0,null,0,0,null,0,null,null,0,null,null,0,null,null,null,1,0,0,0,null,null,null,null,1,0,1,0,null,null,0,null,null,null,1,0,0,0,null,0,0,0,0,null,null,null,0,0,null,null,null,null,null,null]},{"name":"public/app/plugins/datasource/influxdb_08/datasource.js","source":"define([\n  'angular',\n  'lodash',\n  'kbn',\n  './influxSeries',\n  './queryBuilder',\n  './queryCtrl',\n  './funcEditor',\n],\nfunction (angular, _, kbn, InfluxSeries, InfluxQueryBuilder) {\n  'use strict';\n\n  var module = angular.module('grafana.services');\n\n  module.factory('InfluxDatasource_08', function($q, backendSrv, templateSrv) {\n\n    function InfluxDatasource(datasource) {\n      this.urls = _.map(datasource.url.split(','), function(url) {\n        return url.trim();\n      });\n\n      this.username = datasource.username;\n      this.password = datasource.password;\n      this.name = datasource.name;\n      this.basicAuth = datasource.basicAuth;\n    }\n\n    InfluxDatasource.prototype.query = function(options) {\n      var timeFilter = getTimeFilter(options);\n\n      var promises = _.map(options.targets, function(target) {\n        if (target.hide || !((target.series && target.column) || target.query)) {\n          return [];\n        }\n\n        // build query\n        var queryBuilder = new InfluxQueryBuilder(target);\n        var query = queryBuilder.build();\n\n        // replace grafana variables\n        query = query.replace('$timeFilter', timeFilter);\n        query = query.replace(/\\$interval/g, (target.interval || options.interval));\n\n        // replace templated variables\n        query = templateSrv.replace(query, options.scopedVars);\n\n        var alias = target.alias ? templateSrv.replace(target.alias, options.scopedVars) : '';\n\n        var handleResponse = _.partial(handleInfluxQueryResponse, alias, queryBuilder.groupByField);\n        return this._seriesQuery(query).then(handleResponse);\n\n      }, this);\n\n      return $q.all(promises).then(function(results) {\n        return { data: _.flatten(results) };\n      });\n    };\n\n    InfluxDatasource.prototype.annotationQuery = function(annotation, rangeUnparsed) {\n      var timeFilter = getTimeFilter({ range: rangeUnparsed });\n      var query = annotation.query.replace('$timeFilter', timeFilter);\n      query = templateSrv.replace(query);\n\n      return this._seriesQuery(query).then(function(results) {\n        return new InfluxSeries({ seriesList: results, annotation: annotation }).getAnnotations();\n      });\n    };\n\n    InfluxDatasource.prototype.listColumns = function(seriesName) {\n      seriesName = templateSrv.replace(seriesName);\n\n      if(!seriesName.match('^/.*/') && !seriesName.match(/^merge\\(.*\\)/)) {\n        seriesName = '\"' + seriesName+ '\"';\n      }\n\n      return this._seriesQuery('select * from ' + seriesName + ' limit 1').then(function(data) {\n        if (!data) {\n          return [];\n        }\n        return data[0].columns.map(function(item) {\n          return /^\\w+$/.test(item) ? item : ('\"' + item + '\"');\n        });\n      });\n    };\n\n    InfluxDatasource.prototype.listSeries = function(query) {\n      // wrap in regex\n      if (query && query.length > 0 && query[0] !== '/')  {\n        query = '/' + query + '/';\n      }\n\n      return this._seriesQuery('list series ' + query).then(function(data) {\n        if (!data || data.length === 0) {\n          return [];\n        }\n        return _.map(data[0].points, function(point) {\n          return point[1];\n        });\n      });\n    };\n\n    InfluxDatasource.prototype.metricFindQuery = function (query) {\n      var interpolated;\n      try {\n        interpolated = templateSrv.replace(query);\n      }\n      catch (err) {\n        return $q.reject(err);\n      }\n\n      return this._seriesQuery(interpolated)\n        .then(function (results) {\n          if (!results || results.length === 0) { return []; }\n\n          return _.map(results[0].points, function (metric) {\n            return {\n              text: metric[1],\n              expandable: false\n            };\n          });\n        });\n    };\n\n    function retry(deferred, callback, delay) {\n      return callback().then(undefined, function(reason) {\n        if (reason.status !== 0 || reason.status >= 300) {\n          reason.message = 'InfluxDB Error: <br/>' + reason.data;\n          deferred.reject(reason);\n        }\n        else {\n          setTimeout(function() {\n            return retry(deferred, callback, Math.min(delay * 2, 30000));\n          }, delay);\n        }\n      });\n    }\n\n    InfluxDatasource.prototype._seriesQuery = function(query) {\n      return this._influxRequest('GET', '/series', {\n        q: query,\n      });\n    };\n\n    InfluxDatasource.prototype._influxRequest = function(method, url, data) {\n      var _this = this;\n      var deferred = $q.defer();\n\n      retry(deferred, function() {\n        var currentUrl = _this.urls.shift();\n        _this.urls.push(currentUrl);\n\n        var params = {\n          u: _this.username,\n          p: _this.password,\n        };\n\n        if (method === 'GET') {\n          _.extend(params, data);\n          data = null;\n        }\n\n        var options = {\n          method: method,\n          url:    currentUrl + url,\n          params: params,\n          data:   data,\n          inspect: { type: 'influxdb' },\n        };\n\n        options.headers = options.headers || {};\n        if (_this.basicAuth) {\n          options.headers.Authorization = 'Basic ' + _this.basicAuth;\n        }\n\n        return backendSrv.datasourceRequest(options).then(function(response) {\n          deferred.resolve(response.data);\n        });\n      }, 10);\n\n      return deferred.promise;\n    };\n\n    InfluxDatasource.prototype._getDashboardInternal = function(id, isTemp) {\n      var queryString = 'select dashboard from \"grafana.dashboard_' + btoa(id) + '\"';\n\n      if (isTemp) {\n        queryString = 'select dashboard from \"grafana.temp_dashboard_' + btoa(id) + '\"';\n      }\n\n      return this._seriesQuery(queryString).then(function(results) {\n        if (!results || !results.length) {\n          return null;\n        }\n\n        var dashCol = _.indexOf(results[0].columns, 'dashboard');\n        var dashJson = results[0].points[0][dashCol];\n\n        return angular.fromJson(dashJson);\n      }, function() {\n        return null;\n      });\n    };\n\n    InfluxDatasource.prototype.getDashboard = function(id, isTemp) {\n      var self = this;\n      return this._getDashboardInternal(id, isTemp).then(function(dashboard) {\n        if (dashboard !== null)  {\n          return dashboard;\n        }\n\n        // backward compatible load for unslugified ids\n        var slug = kbn.slugifyForUrl(id);\n        if (slug !== id) {\n          return self.getDashboard(slug, isTemp);\n        }\n\n        throw \"Dashboard not found\";\n      }, function(err) {\n        throw  \"Could not load dashboard, \" + err.data;\n      });\n    };\n\n    InfluxDatasource.prototype.deleteDashboard = function(id) {\n      return this._seriesQuery('drop series \"grafana.dashboard_' + btoa(id) + '\"').then(function(results) {\n        if (!results) {\n          throw \"Could not delete dashboard\";\n        }\n        return id;\n      }, function(err) {\n        throw \"Could not delete dashboard, \" + err.data;\n      });\n    };\n\n    InfluxDatasource.prototype.searchDashboards = function(queryString) {\n      var influxQuery = 'select * from /grafana.dashboard_.*/ where ';\n\n      var tagsOnly = queryString.indexOf('tags!:') === 0;\n      if (tagsOnly) {\n        var tagsQuery = queryString.substring(6, queryString.length);\n        influxQuery = influxQuery + 'tags =~ /.*' + tagsQuery + '.*/i';\n      }\n      else {\n        var titleOnly = queryString.indexOf('title:') === 0;\n        if (titleOnly) {\n          var titleQuery = queryString.substring(6, queryString.length);\n          influxQuery = influxQuery + ' title =~ /.*' + titleQuery + '.*/i';\n        }\n        else {\n          influxQuery = influxQuery + '(tags =~ /.*' + queryString + '.*/i or title =~ /.*' + queryString + '.*/i)';\n        }\n      }\n\n      return this._seriesQuery(influxQuery).then(function(results) {\n        var hits = { dashboards: [], tags: [], tagsOnly: false };\n\n        if (!results || !results.length) {\n          return hits;\n        }\n\n        for (var i = 0; i < results.length; i++) {\n          var dashCol = _.indexOf(results[i].columns, 'title');\n          var tagsCol = _.indexOf(results[i].columns, 'tags');\n          var idCol = _.indexOf(results[i].columns, 'id');\n\n          var hit =  {\n            id: results[i].points[0][dashCol],\n            title: results[i].points[0][dashCol],\n            tags: results[i].points[0][tagsCol].split(\",\")\n          };\n\n          if (idCol !== -1) {\n            hit.id = results[i].points[0][idCol];\n          }\n\n          hit.tags = hit.tags[0] ? hit.tags : [];\n          hits.dashboards.push(hit);\n        }\n        return hits;\n      });\n    };\n\n    function handleInfluxQueryResponse(alias, groupByField, seriesList) {\n      var influxSeries = new InfluxSeries({\n        seriesList: seriesList,\n        alias: alias,\n        groupByField: groupByField\n      });\n\n      return influxSeries.getTimeSeries();\n    }\n\n    function getTimeFilter(options) {\n      var from = getInfluxTime(options.range.from);\n      var until = getInfluxTime(options.range.to);\n      var fromIsAbsolute = from[from.length-1] === 's';\n\n      if (until === 'now()' && !fromIsAbsolute) {\n        return 'time > ' + from;\n      }\n\n      return 'time > ' + from + ' and time < ' + until;\n    }\n\n    function getInfluxTime(date) {\n      if (_.isString(date)) {\n        return date.replace('now', 'now()');\n      }\n\n      return to_utc_epoch_seconds(date);\n    }\n\n    function to_utc_epoch_seconds(date) {\n      return (date.getTime() / 1000).toFixed(0) + 's';\n    }\n\n    return InfluxDatasource;\n\n  });\n\n});\n","coverage":[1,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,1,4,4,null,null,4,4,4,4,null,null,4,3,null,3,3,0,null,null,null,3,3,null,null,3,3,null,null,3,null,3,null,3,3,null,null,null,3,3,null,null,null,4,1,1,1,null,1,1,null,null,null,4,0,null,0,0,null,null,0,0,0,null,0,0,null,null,null,null,4,null,0,0,null,null,0,0,0,null,0,0,null,null,null,null,4,0,0,0,null,null,0,null,null,0,null,0,null,0,0,null,null,null,null,null,null,null,1,4,0,0,0,null,null,0,0,null,null,null,null,null,4,4,null,null,null,null,4,4,4,null,4,4,4,null,4,null,null,null,null,4,4,4,null,null,4,null,null,null,null,null,null,null,4,4,0,null,null,4,4,null,null,null,4,null,null,4,0,null,0,0,null,null,0,0,0,null,null,0,0,null,0,null,0,null,null,null,4,0,0,0,0,null,null,null,0,0,0,null,null,0,null,0,null,null,null,4,0,0,0,null,0,null,0,null,null,null,4,0,null,0,0,0,0,null,null,0,0,0,0,null,null,0,null,null,null,0,0,null,0,0,null,null,0,0,0,0,null,0,null,null,null,null,null,0,0,null,null,0,0,null,0,null,null,null,1,3,null,null,null,null,null,3,null,null,1,4,4,4,null,4,4,null,null,0,null,null,1,8,8,null,null,0,null,null,1,0,null,null,4,null,null,null,null,null]},{"name":"public/app/services/backendSrv.js","source":"define([\n  'angular',\n  'lodash',\n  'config',\n],\nfunction (angular, _, config) {\n  'use strict';\n\n  var module = angular.module('grafana.services');\n\n  module.service('backendSrv', function($http, alertSrv, $timeout) {\n    var self = this;\n\n    this.get = function(url, params) {\n      return this.request({ method: 'GET', url: url, params: params });\n    };\n\n    this.delete = function(url) {\n      return this.request({ method: 'DELETE', url: url });\n    };\n\n    this.post = function(url, data) {\n      return this.request({ method: 'POST', url: url, data: data });\n    };\n\n    this.patch = function(url, data) {\n      return this.request({ method: 'PATCH', url: url, data: data });\n    };\n\n    this.put = function(url, data) {\n      return this.request({ method: 'PUT', url: url, data: data });\n    };\n\n    this._handleError = function(err) {\n      return function() {\n        if (err.isHandled) {\n          return;\n        }\n\n        if (err.status === 422) {\n          alertSrv.set(\"Validation failed\", \"\", \"warning\", 4000);\n          throw err.data;\n        }\n\n        var data = err.data || { message: 'Unexpected error' };\n\n        if (_.isString(data)) {\n          data = { message: data };\n        }\n\n        data.severity = 'error';\n\n        if (err.status < 500) {\n          data.severity = \"warning\";\n        }\n\n        if (data.message) {\n          alertSrv.set(\"Problem!\", data.message, data.severity, 10000);\n        }\n\n        throw data;\n      };\n    };\n\n    this.request = function(options) {\n      options.retry = options.retry || 0;\n      var requestIsLocal = options.url.indexOf('/') === 0;\n      var firstAttempt = options.retry === 0;\n\n      if (requestIsLocal && !options.hasSubUrl) {\n        options.url = config.appSubUrl + options.url;\n        options.hasSubUrl = true;\n      }\n\n      return $http(options).then(function(results) {\n        if (options.method !== 'GET') {\n          if (results && results.data.message) {\n            alertSrv.set(results.data.message, '', 'success', 3000);\n          }\n        }\n        return results.data;\n      }, function(err) {\n        // handle unauthorized\n        if (err.status === 401 && firstAttempt) {\n          return self.loginPing().then(function() {\n            options.retry = 1;\n            return self.request(options);\n          });\n        }\n\n        $timeout(self._handleError(err), 50);\n        throw err;\n      });\n    };\n\n    this.datasourceRequest = function(options) {\n      options.retry = options.retry || 0;\n      var requestIsLocal = options.url.indexOf('/') === 0;\n      var firstAttempt = options.retry === 0;\n\n      return $http(options).then(null, function(err) {\n        // handle unauthorized for backend requests\n        if (requestIsLocal && firstAttempt  && err.status === 401) {\n          return self.loginPing().then(function() {\n            options.retry = 1;\n            return self.datasourceRequest(options);\n          });\n        }\n\n        throw err;\n      });\n    };\n\n    this.loginPing = function() {\n      return this.request({url: '/api/login/ping', method: 'GET', retry: 1 });\n    };\n\n    this.search = function(query) {\n      return this.get('/api/search', query);\n    };\n\n    this.getDashboard = function(slug) {\n      return this.get('/api/dashboards/db/' + slug);\n    };\n\n    this.saveDashboard = function(dash, options) {\n      options = (options || {});\n      return this.post('/api/dashboards/db/', {dashboard: dash, overwrite: options.overwrite === true});\n    };\n\n  });\n});\n","coverage":[1,null,null,null,null,null,null,null,1,null,1,4,null,4,0,null,null,4,0,null,null,4,0,null,null,4,0,null,null,4,0,null,null,4,0,0,0,null,null,0,0,0,null,null,0,null,0,0,null,null,0,null,0,0,null,null,0,0,null,null,0,null,null,null,4,0,0,0,null,0,0,0,null,null,0,0,0,0,null,null,0,null,null,0,0,0,0,null,null,null,0,0,null,null,null,4,4,4,4,null,4,null,0,0,0,0,null,null,null,0,null,null,null,4,0,null,null,4,0,null,null,4,0,null,null,4,0,0,null,null,null,null,null]},{"name":"public/app/plugins/datasource/influxdb/queryBuilder.js","source":"define([\n    'lodash'\n],\nfunction (_) {\n  'use strict';\n\n  function InfluxQueryBuilder(target) {\n    this.target = target;\n  }\n\n  var p = InfluxQueryBuilder.prototype;\n\n  p.build = function() {\n    return this.target.rawQuery ? this._modifyRawQuery() : this._buildQuery();\n  };\n\n  p._buildQuery = function() {\n    var target = this.target;\n\n    console.log('Build Query: target = ', target);\n\n    if (!target.measurement) {\n      throw \"Metric measurement is missing\";\n    }\n\n    var query = 'SELECT ';\n    var measurement = target.measurement;\n    var aggregationFunc = target.function || 'mean';\n\n    if(!measurement.match('^/.*/') && !measurement.match(/^merge\\(.*\\)/)) {\n      measurement = '\"' + measurement+ '\"';\n    }\n\n    query +=  aggregationFunc + '(value)';\n    query += ' FROM ' + measurement + ' WHERE $timeFilter';\n    query += _.map(target.tags, function(value, key) {\n      return ' AND ' + key + '=' + \"'\" + value + \"'\";\n    }).join('');\n\n    query += ' GROUP BY time($interval)';\n\n    if (target.fill) {\n      query += ' fill(' + target.fill + ')';\n    }\n\n    query += \" ORDER BY asc\";\n    target.query = query;\n\n    return query;\n  };\n\n  p._modifyRawQuery = function () {\n    var query = this.target.query.replace(\";\", \"\");\n    return query;\n  };\n\n  return InfluxQueryBuilder;\n});\n","coverage":[1,null,null,null,null,null,1,2,null,null,1,null,1,2,null,null,1,2,null,2,null,2,0,null,null,2,2,2,null,2,2,null,null,2,2,2,1,null,null,2,null,2,0,null,null,2,2,null,2,null,null,1,0,0,null,null,1,null,null]},{"name":"public/app/features/panel/panelHelper.js","source":"define([\n  'angular',\n  'lodash',\n  'kbn',\n  'jquery',\n],\nfunction (angular, _, kbn, $) {\n  'use strict';\n\n  var module = angular.module('grafana.services');\n\n  module.service('panelHelper', function(timeSrv) {\n\n    this.updateTimeRange = function(scope) {\n      scope.range = timeSrv.timeRange();\n      scope.rangeUnparsed = timeSrv.timeRange(false);\n      this.applyPanelTimeOverrides(scope);\n\n      if (scope.panel.maxDataPoints) {\n        scope.resolution = scope.panel.maxDataPoints;\n      }\n      else {\n        scope.resolution = Math.ceil($(window).width() * (scope.panel.span / 12));\n      }\n      scope.interval = kbn.calculateInterval(scope.range, scope.resolution, scope.panel.interval);\n    };\n\n    this.applyPanelTimeOverrides = function(scope) {\n      scope.panelMeta.timeInfo = '';\n\n      // check panel time overrrides\n      if (scope.panel.timeFrom) {\n        if (!kbn.isValidTimeSpan(scope.panel.timeFrom)) {\n          scope.panelMeta.timeInfo = 'invalid time override';\n          return;\n        }\n\n        if (_.isString(scope.rangeUnparsed.from)) {\n          scope.panelMeta.timeInfo = \"last \" + scope.panel.timeFrom;\n          scope.rangeUnparsed.from = 'now-' + scope.panel.timeFrom;\n          scope.range.from = kbn.parseDate(scope.rangeUnparsed.from);\n        }\n      }\n\n      if (scope.panel.timeShift) {\n        if (!kbn.isValidTimeSpan(scope.panel.timeShift)) {\n          scope.panelMeta.timeInfo = 'invalid timeshift';\n          return;\n        }\n\n        var timeShift = '-' + scope.panel.timeShift;\n        scope.panelMeta.timeInfo += ' timeshift ' + timeShift;\n        scope.range.from = kbn.parseDateMath(timeShift, scope.range.from);\n        scope.range.to = kbn.parseDateMath(timeShift, scope.range.to);\n\n        scope.rangeUnparsed = scope.range;\n      }\n\n      if (scope.panel.hideTimeOverride) {\n        scope.panelMeta.timeInfo = '';\n      }\n    };\n\n    this.issueMetricQuery = function(scope, datasource) {\n      var metricsQuery = {\n        range: scope.rangeUnparsed,\n        interval: scope.interval,\n        targets: scope.panel.targets,\n        format: scope.panel.renderer === 'png' ? 'png' : 'json',\n        maxDataPoints: scope.resolution,\n        scopedVars: scope.panel.scopedVars,\n        cacheTimeout: scope.panel.cacheTimeout\n      };\n\n      return datasource.query(metricsQuery).then(function(results) {\n        if (scope.dashboard.snapshot) {\n          scope.panel.snapshotData = results;\n        }\n\n        return results;\n      });\n    };\n\n  });\n});\n","coverage":[1,null,null,null,null,null,null,null,null,1,null,1,null,1,1,1,1,null,1,0,null,null,1,null,1,null,null,1,1,null,null,1,0,0,0,null,null,0,0,0,0,null,null,null,1,0,0,0,null,null,0,0,0,0,null,0,null,null,1,0,null,null,null,1,1,null,null,null,null,null,null,null,null,null,1,1,0,null,null,1,null,null,null,null,null,null]},{"name":"public/app/services/alertSrv.js","source":"define([\n  'angular',\n  'lodash'\n],\nfunction (angular, _) {\n  'use strict';\n\n  var module = angular.module('grafana.services');\n\n  module.service('alertSrv', function($timeout, $sce, $rootScope, $modal, $q) {\n    var self = this;\n\n    this.init = function() {\n      $rootScope.onAppEvent('alert-error', function(e, alert) {\n        self.set(alert[0], alert[1], 'error');\n      });\n      $rootScope.onAppEvent('alert-warning', function(e, alert) {\n        self.set(alert[0], alert[1], 'warning', 5000);\n      });\n      $rootScope.onAppEvent('alert-success', function(e, alert) {\n        self.set(alert[0], alert[1], 'success', 3000);\n      });\n      $rootScope.onAppEvent('confirm-modal', this.showConfirmModal);\n    };\n\n    // List of all alert objects\n    this.list = [];\n\n    this.set = function(title,text,severity,timeout) {\n      var newAlert = {\n        title: title || '',\n        text: text || '',\n        severity: severity || 'info',\n      };\n\n      var newAlertJson = angular.toJson(newAlert);\n\n      // remove same alert if it already exists\n      _.remove(self.list, function(value) {\n        return angular.toJson(value) === newAlertJson;\n      });\n\n      self.list.push(newAlert);\n      if (timeout > 0) {\n        $timeout(function() {\n          self.list = _.without(self.list,newAlert);\n        }, timeout);\n      }\n\n      return(newAlert);\n    };\n\n    this.clear = function(alert) {\n      self.list = _.without(self.list,alert);\n    };\n\n    this.clearAll = function() {\n      self.list = [];\n    };\n\n    this.showConfirmModal = function(e, payload) {\n      var scope = $rootScope.$new();\n\n      scope.title = payload.title;\n      scope.text = payload.text;\n      scope.onConfirm = payload.onConfirm;\n      scope.icon = payload.icon || \"fa-check\";\n      scope.yesText = payload.yesText || \"Yes\";\n      scope.noText = payload.noText || \"Cancel\";\n\n      var confirmModal = $modal({\n        template: './app/partials/confirm_modal.html',\n        persist: false,\n        modalClass: 'confirm-modal',\n        show: false,\n        scope: scope,\n        keyboard: false\n      });\n\n      $q.when(confirmModal).then(function(modalEl) {\n        modalEl.modal('show');\n      });\n\n    };\n\n  });\n});\n","coverage":[1,null,null,null,null,null,null,1,null,1,4,null,4,0,0,null,0,0,null,0,0,null,0,null,null,null,4,null,4,0,null,null,null,null,null,0,null,null,0,0,null,null,0,0,0,0,null,null,null,0,null,null,4,0,null,null,4,0,null,null,4,0,null,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null]},{"name":"public/app/features/panel/panelSrv.js","source":"define([\n  'angular',\n  'lodash',\n  'config',\n],\nfunction (angular, _, config) {\n  'use strict';\n\n  var module = angular.module('grafana.services');\n\n  module.service('panelSrv', function($rootScope, $timeout, datasourceSrv, $q) {\n\n    this.init = function($scope) {\n\n      if (!$scope.panel.span) { $scope.panel.span = 12; }\n\n      $scope.inspector = {};\n\n      $scope.editPanel = function() {\n        $scope.toggleFullscreen(true);\n      };\n\n      $scope.sharePanel = function() {\n        $scope.appEvent('show-modal', {\n          src: './app/features/dashboard/partials/shareModal.html',\n          scope: $scope.$new()\n        });\n      };\n\n      $scope.editPanelJson = function() {\n        $scope.appEvent('show-json-editor', { object: $scope.panel, updateHandler: $scope.replacePanel });\n      };\n\n      $scope.duplicatePanel = function() {\n        $scope.dashboard.duplicatePanel($scope.panel, $scope.row);\n      };\n\n      $scope.updateColumnSpan = function(span) {\n        $scope.updatePanelSpan($scope.panel, span);\n\n        $timeout(function() {\n          $scope.$broadcast('render');\n        });\n      };\n\n      $scope.addDataQuery = function() {\n        $scope.panel.targets.push({target: ''});\n      };\n\n      $scope.removeDataQuery = function (query) {\n        $scope.panel.targets = _.without($scope.panel.targets, query);\n        $scope.get_data();\n      };\n\n      $scope.setDatasource = function(datasource) {\n        $scope.panel.datasource = datasource;\n        $scope.datasource = null;\n        $scope.get_data();\n      };\n\n      $scope.toggleEditorHelp = function(index) {\n        if ($scope.editorHelpIndex === index) {\n          $scope.editorHelpIndex = null;\n          return;\n        }\n        $scope.editorHelpIndex = index;\n      };\n\n      $scope.isNewPanel = function() {\n        return $scope.panel.title === config.new_panel_title;\n      };\n\n      $scope.toggleFullscreen = function(edit) {\n        if (edit && $scope.dashboardMeta.canEdit === false) {\n          $scope.appEvent('alert-warning', [\n            'Dashboard not editable',\n            'Use Save As.. feature to create an editable copy of this dashboard.'\n          ]);\n          return;\n        }\n\n        $scope.dashboardViewState.update({ fullscreen: true, edit: edit, panelId: $scope.panel.id });\n      };\n\n      $scope.otherPanelInFullscreenMode = function() {\n        return $scope.dashboardViewState.fullscreen && !$scope.fullscreen;\n      };\n\n      $scope.getCurrentDatasource = function() {\n        if ($scope.datasource) {\n          return $q.when($scope.datasource);\n        }\n\n        return datasourceSrv.get($scope.panel.datasource);\n      };\n\n      $scope.get_data = function() {\n        if ($scope.otherPanelInFullscreenMode()) { return; }\n\n        if ($scope.panel.snapshotData) {\n          if ($scope.loadSnapshot) {\n            $scope.loadSnapshot($scope.panel.snapshotData);\n          }\n          return;\n        }\n\n        delete $scope.panelMeta.error;\n        $scope.panelMeta.loading = true;\n\n        $scope.getCurrentDatasource().then(function(datasource) {\n          $scope.datasource = datasource;\n          return $scope.refreshData($scope.datasource) || $q.when({});\n        }).then(function() {\n          $scope.panelMeta.loading = false;\n        }, function(err) {\n          console.log('Panel data error:', err);\n          $scope.panelMeta.loading = false;\n          $scope.panelMeta.error = err.message || \"Timeseries data request error\";\n          $scope.inspector.error = err;\n        });\n      };\n\n      if ($scope.refreshData) {\n        $scope.$on(\"refresh\", $scope.get_data);\n      }\n\n      // Post init phase\n      $scope.fullscreen = false;\n      $scope.editor = { index: 1 };\n\n      $scope.dashboardViewState.registerPanel($scope);\n      $scope.datasources = datasourceSrv.getMetricSources();\n\n      if (!$scope.skipDataOnInit) {\n        $timeout(function() {\n          $scope.get_data();\n        }, 30);\n      }\n    };\n  });\n\n});\n","coverage":[1,null,null,null,null,null,null,null,1,null,1,null,1,null,1,null,1,null,1,0,null,null,1,0,null,null,null,null,null,1,0,null,null,1,0,null,null,1,0,null,0,0,null,null,null,1,0,null,null,1,0,0,null,null,1,0,0,0,null,null,1,0,0,0,null,0,null,null,1,0,null,null,1,0,0,null,null,null,0,null,null,0,null,null,1,0,null,null,1,0,0,null,null,0,null,null,1,0,null,0,0,0,null,0,null,null,0,0,null,0,0,0,null,0,null,0,0,0,0,null,null,null,1,1,null,null,null,1,1,null,1,1,null,1,0,0,null,null,null,null,null,null,null]},{"name":"public/app/panels/graph/graph.js","source":"define([\n  'angular',\n  'jquery',\n  'kbn',\n  'moment',\n  'lodash',\n  './graph.tooltip',\n  'jquery.flot',\n  'jquery.flot.events',\n  'jquery.flot.selection',\n  'jquery.flot.time',\n  'jquery.flot.stack',\n  'jquery.flot.stackpercent',\n  'jquery.flot.fillbelow',\n  'jquery.flot.crosshair'\n],\nfunction (angular, $, kbn, moment, _, GraphTooltip) {\n  'use strict';\n\n  var module = angular.module('grafana.directives');\n\n  module.directive('grafanaGraph', function($rootScope, timeSrv) {\n    return {\n      restrict: 'A',\n      template: '<div> </div>',\n      link: function(scope, elem) {\n        var dashboard = scope.dashboard;\n        var data, annotations;\n        var sortedSeries;\n        var graphHeight;\n        var legendSideLastValue = null;\n        scope.crosshairEmiter = false;\n\n        scope.onAppEvent('setCrosshair', function(event, info) {\n          // do not need to to this if event is from this panel\n          if (info.scope === scope) {\n            return;\n          }\n\n          if(dashboard.sharedCrosshair) {\n            var plot = elem.data().plot;\n            if (plot) {\n              plot.setCrosshair({ x: info.pos.x, y: info.pos.y });\n            }\n          }\n        });\n\n        scope.onAppEvent('clearCrosshair', function() {\n          var plot = elem.data().plot;\n          if (plot) {\n            plot.clearCrosshair();\n          }\n        });\n\n        // Receive render events\n        scope.$on('render',function(event, renderData) {\n          data = renderData || data;\n          if (!data) {\n            scope.get_data();\n            return;\n          }\n          annotations = data.annotations || annotations;\n          render_panel();\n        });\n\n        function getLegendHeight(panelHeight) {\n          if (!scope.panel.legend.show || scope.panel.legend.rightSide) {\n            return 0;\n          }\n          if (scope.panel.legend.alignAsTable) {\n            var total = 30 + (25 * data.length);\n            return Math.min(total, Math.floor(panelHeight/2));\n          } else {\n            return 26;\n          }\n        }\n\n        function setElementHeight() {\n          try {\n            graphHeight = scope.height || scope.panel.height || scope.row.height;\n            if (_.isString(graphHeight)) {\n              graphHeight = parseInt(graphHeight.replace('px', ''), 10);\n            }\n\n            graphHeight -= 5; // padding\n            graphHeight -= scope.panel.title ? 24 : 9; // subtract panel title bar\n\n            graphHeight = graphHeight - getLegendHeight(graphHeight); // subtract one line legend\n\n            elem.css('height', graphHeight + 'px');\n\n            return true;\n          } catch(e) { // IE throws errors sometimes\n            return false;\n          }\n        }\n\n        function shouldAbortRender() {\n          if (!data) {\n            return true;\n          }\n\n          if ($rootScope.fullscreen && !scope.fullscreen) {\n            return true;\n          }\n\n          if (!setElementHeight()) { return true; }\n\n          if (_.isString(data)) {\n            render_panel_as_graphite_png(data);\n            return true;\n          }\n\n          if (elem.width() === 0) {\n            return true;\n          }\n        }\n\n        function drawHook(plot) {\n          // Update legend values\n          var yaxis = plot.getYAxes();\n          for (var i = 0; i < data.length; i++) {\n            var series = data[i];\n            var axis = yaxis[series.yaxis - 1];\n            var formater = kbn.valueFormats[scope.panel.y_formats[series.yaxis - 1]];\n\n            // decimal override\n            if (_.isNumber(scope.panel.decimals)) {\n              series.updateLegendValues(formater, scope.panel.decimals, null);\n            } else {\n              // auto decimals\n              // legend and tooltip gets one more decimal precision\n              // than graph legend ticks\n              var tickDecimals = (axis.tickDecimals || -1) + 1;\n              series.updateLegendValues(formater, tickDecimals, axis.scaledDecimals + 2);\n            }\n\n            if(!scope.$$phase) { scope.$digest(); }\n          }\n\n          // add left axis labels\n          if (scope.panel.leftYAxisLabel) {\n            var yaxisLabel = $(\"<div class='axisLabel left-yaxis-label'></div>\")\n              .text(scope.panel.leftYAxisLabel)\n              .appendTo(elem);\n\n            yaxisLabel.css(\"margin-top\", yaxisLabel.width() / 2);\n          }\n\n          // add right axis labels\n          if (scope.panel.rightYAxisLabel) {\n            var rightLabel = $(\"<div class='axisLabel right-yaxis-label'></div>\")\n              .text(scope.panel.rightYAxisLabel)\n              .appendTo(elem);\n\n            rightLabel.css(\"margin-top\", rightLabel.width() / 2);\n          }\n        }\n\n        function processOffsetHook(plot, gridMargin) {\n          if (scope.panel.leftYAxisLabel) { gridMargin.left = 20; }\n          if (scope.panel.rightYAxisLabel) { gridMargin.right = 20; }\n        }\n\n        // Function for rendering panel\n        function render_panel() {\n          if (shouldAbortRender()) {\n            return;\n          }\n\n          var panel = scope.panel;\n          var stack = panel.stack ? true : null;\n\n          // Populate element\n          var options = {\n            hooks: {\n              draw: [drawHook],\n              processOffset: [processOffsetHook],\n            },\n            legend: { show: false },\n            series: {\n              stackpercent: panel.stack ? panel.percentage : false,\n              stack: panel.percentage ? null : stack,\n              lines:  {\n                show: panel.lines,\n                zero: false,\n                fill: translateFillOption(panel.fill),\n                lineWidth: panel.linewidth,\n                steps: panel.steppedLine\n              },\n              bars:   {\n                show: panel.bars,\n                fill: 1,\n                barWidth: 1,\n                zero: false,\n                lineWidth: 0\n              },\n              points: {\n                show: panel.points,\n                fill: 1,\n                fillColor: false,\n                radius: panel.points ? panel.pointradius : 2\n                // little points when highlight points\n              },\n              shadowSize: 1\n            },\n            yaxes: [],\n            xaxis: {},\n            grid: {\n              minBorderMargin: 0,\n              markings: [],\n              backgroundColor: null,\n              borderWidth: 0,\n              hoverable: true,\n              color: '#c8c8c8',\n              margin: { left: 0, right: 0 },\n            },\n            selection: {\n              mode: \"x\",\n              color: '#666'\n            },\n            crosshair: {\n              mode: panel.tooltip.shared || dashboard.sharedCrosshair ? \"x\" : null\n            }\n          };\n\n          for (var i = 0; i < data.length; i++) {\n            var series = data[i];\n            series.applySeriesOverrides(panel.seriesOverrides);\n            series.data = series.getFlotPairs(panel.nullPointMode, panel.y_formats);\n\n            // if hidden remove points and disable stack\n            if (scope.hiddenSeries[series.alias]) {\n              series.data = [];\n              series.stack = false;\n            }\n          }\n\n          if (data.length && data[0].stats.timeStep) {\n            options.series.bars.barWidth = data[0].stats.timeStep / 1.5;\n          }\n\n          addTimeAxis(options);\n          addGridThresholds(options, panel);\n          addAnnotations(options);\n          configureAxisOptions(data, options);\n\n          sortedSeries = _.sortBy(data, function(series) { return series.zindex; });\n\n          function callPlot() {\n            try {\n              $.plot(elem, sortedSeries, options);\n            } catch (e) {\n              console.log('flotcharts error', e);\n            }\n          }\n\n          if (shouldDelayDraw(panel)) {\n            // temp fix for legends on the side, need to render twice to get dimensions right\n            callPlot();\n            setTimeout(callPlot, 50);\n            legendSideLastValue = panel.legend.rightSide;\n          }\n          else {\n            callPlot();\n          }\n        }\n\n        function translateFillOption(fill) {\n          return fill === 0 ? 0.001 : fill/10;\n        }\n\n        function shouldDelayDraw(panel) {\n          if (panel.legend.rightSide) {\n            return true;\n          }\n          if (legendSideLastValue !== null && panel.legend.rightSide !== legendSideLastValue) {\n            return true;\n          }\n        }\n\n        function addTimeAxis(options) {\n          var ticks = elem.width() / 100;\n          var min = _.isUndefined(scope.range.from) ? null : scope.range.from.getTime();\n          var max = _.isUndefined(scope.range.to) ? null : scope.range.to.getTime();\n\n          options.xaxis = {\n            timezone: dashboard.timezone,\n            show: scope.panel['x-axis'],\n            mode: \"time\",\n            min: min,\n            max: max,\n            label: \"Datetime\",\n            ticks: ticks,\n            timeformat: time_format(scope.interval, ticks, min, max),\n          };\n        }\n\n        function addGridThresholds(options, panel) {\n          if (_.isNumber(panel.grid.threshold1)) {\n            var limit1 = panel.grid.thresholdLine ? panel.grid.threshold1 : (panel.grid.threshold2 || null);\n            options.grid.markings.push({\n              yaxis: { from: panel.grid.threshold1, to: limit1 },\n              color: panel.grid.threshold1Color\n            });\n\n            if (_.isNumber(panel.grid.threshold2)) {\n              var limit2;\n              if (panel.grid.thresholdLine) {\n                limit2 = panel.grid.threshold2;\n              } else {\n                limit2 = panel.grid.threshold1 > panel.grid.threshold2 ?  -Infinity : +Infinity;\n              }\n              options.grid.markings.push({\n                yaxis: { from: panel.grid.threshold2, to: limit2 },\n                color: panel.grid.threshold2Color\n              });\n            }\n          }\n        }\n\n        function addAnnotations(options) {\n          if(!annotations || annotations.length === 0) {\n            return;\n          }\n\n          var types = {};\n\n          _.each(annotations, function(event) {\n            if (!types[event.annotation.name]) {\n              types[event.annotation.name] = {\n                level: _.keys(types).length + 1,\n                icon: {\n                  icon: \"fa fa-chevron-down\",\n                  size: event.annotation.iconSize,\n                  color: event.annotation.iconColor,\n                }\n              };\n            }\n\n            if (event.annotation.showLine) {\n              options.grid.markings.push({\n                color: event.annotation.lineColor,\n                lineWidth: 1,\n                xaxis: { from: event.min, to: event.max }\n              });\n            }\n          });\n\n          options.events = {\n            levels: _.keys(types).length + 1,\n            data: annotations,\n            types: types\n          };\n        }\n\n        function configureAxisOptions(data, options) {\n          var defaults = {\n            position: 'left',\n            show: scope.panel['y-axis'],\n            min: scope.panel.grid.leftMin,\n            index: 1,\n            logBase: scope.panel.grid.leftLogBase || 1,\n            max: scope.panel.percentage && scope.panel.stack ? 100 : scope.panel.grid.leftMax,\n          };\n\n          options.yaxes.push(defaults);\n\n          if (_.findWhere(data, {yaxis: 2})) {\n            var secondY = _.clone(defaults);\n            secondY.index = 2,\n            secondY.logBase = scope.panel.grid.rightLogBase || 2,\n            secondY.position = 'right';\n            secondY.min = scope.panel.grid.rightMin;\n            secondY.max = scope.panel.percentage && scope.panel.stack ? 100 : scope.panel.grid.rightMax;\n            options.yaxes.push(secondY);\n\n            applyLogScale(options.yaxes[1], data);\n            configureAxisMode(options.yaxes[1], scope.panel.y_formats[1]);\n          }\n\n          applyLogScale(options.yaxes[0], data);\n          configureAxisMode(options.yaxes[0], scope.panel.y_formats[0]);\n        }\n\n        function applyLogScale(axis, data) {\n          if (axis.logBase === 1) {\n            return;\n          }\n\n          var series, i;\n          var max = axis.max;\n\n          if (max === null) {\n            for (i = 0; i < data.length; i++) {\n              series = data[i];\n              if (series.yaxis === axis.index) {\n                if (max < series.stats.max) {\n                  max = series.stats.max;\n                }\n              }\n            }\n            if (max === void 0) {\n              max = Number.MAX_VALUE;\n            }\n          }\n\n          axis.min = axis.min !== null ? axis.min : 0;\n          axis.ticks = [0, 1];\n          var nextTick = 1;\n\n          while (true) {\n            nextTick = nextTick * axis.logBase;\n            axis.ticks.push(nextTick);\n            if (nextTick > max) {\n              break;\n            }\n          }\n\n          if (axis.logBase === 10) {\n            axis.transform = function(v) { return Math.log(v+0.1); };\n            axis.inverseTransform  = function (v) { return Math.pow(10,v); };\n          } else {\n            axis.transform = function(v) { return Math.log(v+0.1) / Math.log(axis.logBase); };\n            axis.inverseTransform  = function (v) { return Math.pow(axis.logBase,v); };\n          }\n        }\n\n        function configureAxisMode(axis, format) {\n          axis.tickFormatter = function(val, axis) {\n            return kbn.valueFormats[format](val, axis.tickDecimals, axis.scaledDecimals);\n          };\n        }\n\n        function time_format(interval, ticks, min, max) {\n          if (min && max && ticks) {\n            var secPerTick = ((max - min) / ticks) / 1000;\n\n            if (secPerTick <= 45) {\n              return \"%H:%M:%S\";\n            }\n            if (secPerTick <= 7200) {\n              return \"%H:%M\";\n            }\n            if (secPerTick <= 80000) {\n              return \"%m/%d %H:%M\";\n            }\n            if (secPerTick <= 2419200) {\n              return \"%m/%d\";\n            }\n            return \"%Y-%m\";\n          }\n\n          return \"%H:%M\";\n        }\n\n        function render_panel_as_graphite_png(url) {\n          url += '&width=' + elem.width();\n          url += '&height=' + elem.css('height').replace('px', '');\n          url += '&bgcolor=1f1f1f'; // @grayDarker & @grafanaPanelBackground\n          url += '&fgcolor=BBBFC2'; // @textColor & @grayLighter\n          url += scope.panel.stack ? '&areaMode=stacked' : '';\n          url += scope.panel.fill !== 0 ? ('&areaAlpha=' + (scope.panel.fill/10).toFixed(1)) : '';\n          url += scope.panel.linewidth !== 0 ? '&lineWidth=' + scope.panel.linewidth : '';\n          url += scope.panel.legend.show ? '&hideLegend=false' : '&hideLegend=true';\n          url += scope.panel.grid.leftMin !== null ? '&yMin=' + scope.panel.grid.leftMin : '';\n          url += scope.panel.grid.leftMax !== null ? '&yMax=' + scope.panel.grid.leftMax : '';\n          url += scope.panel.grid.rightMin !== null ? '&yMin=' + scope.panel.grid.rightMin : '';\n          url += scope.panel.grid.rightMax !== null ? '&yMax=' + scope.panel.grid.rightMax : '';\n          url += scope.panel['x-axis'] ? '' : '&hideAxes=true';\n          url += scope.panel['y-axis'] ? '' : '&hideYAxis=true';\n\n          switch(scope.panel.y_formats[0]) {\n            case 'bytes':\n              url += '&yUnitSystem=binary';\n              break;\n            case 'bits':\n              url += '&yUnitSystem=binary';\n              break;\n            case 'bps':\n              url += '&yUnitSystem=si';\n              break;\n            case 'Bps':\n              url += '&yUnitSystem=si';\n              break;\n            case 'short':\n              url += '&yUnitSystem=si';\n              break;\n            case 'joule':\n              url += '&yUnitSystem=si';\n              break;\n            case 'watt':\n              url += '&yUnitSystem=si';\n              break;\n            case 'ev':\n              url += '&yUnitSystem=si';\n              break;\n            case 'none':\n              url += '&yUnitSystem=none';\n              break;\n          }\n\n          switch(scope.panel.nullPointMode) {\n            case 'connected':\n              url += '&lineMode=connected';\n              break;\n            case 'null':\n              break; // graphite default lineMode\n            case 'null as zero':\n              url += \"&drawNullAsZero=true\";\n              break;\n          }\n\n          url += scope.panel.steppedLine ? '&lineMode=staircase' : '';\n\n          elem.html('<img src=\"' + url + '\"></img>');\n        }\n\n        new GraphTooltip(elem, dashboard, scope, function() {\n          return sortedSeries;\n        });\n\n        elem.bind(\"plotselected\", function (event, ranges) {\n          scope.$apply(function() {\n            timeSrv.setTime({\n              from  : moment.utc(ranges.xaxis.from).toDate(),\n              to    : moment.utc(ranges.xaxis.to).toDate(),\n            });\n          });\n        });\n      }\n    };\n  });\n\n});\n","coverage":[1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,9,null,null,null,9,9,9,9,9,9,null,9,null,0,0,null,null,0,0,0,0,null,null,null,null,9,0,0,0,null,null,null,null,9,9,9,0,0,null,9,9,null,null,1,9,9,null,0,0,0,null,0,null,null,null,1,9,9,9,9,null,null,9,9,null,9,null,9,null,9,null,0,null,null,null,1,9,0,null,null,9,0,null,null,9,null,9,0,0,null,null,9,0,null,null,null,1,null,0,0,0,0,0,null,null,0,0,null,null,null,null,0,0,null,null,0,null,null,null,0,0,null,null,null,0,null,null,null,0,0,null,null,null,0,null,null,null,1,0,0,null,null,null,1,9,0,null,null,9,9,null,null,9,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,9,18,18,18,null,null,18,1,1,null,null,null,9,9,null,null,9,9,9,9,null,18,null,1,9,9,null,0,null,null,null,9,null,0,0,0,null,null,9,null,null,null,1,9,null,null,1,9,0,null,9,0,null,null,null,1,9,9,9,null,9,null,null,null,null,null,null,null,null,null,null,null,1,9,3,3,null,null,null,null,3,2,2,0,null,2,null,2,null,null,null,null,null,null,null,1,9,9,null,null,0,null,0,0,0,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,1,9,null,null,null,null,null,null,null,null,9,null,9,0,0,null,null,0,0,0,null,0,0,null,null,9,9,null,null,1,9,8,null,null,1,1,null,1,1,2,2,2,1,null,null,null,1,0,null,null,null,1,1,1,null,1,1,1,1,1,null,null,null,1,1,1,null,0,0,null,null,null,1,9,0,null,null,null,1,9,0,null,0,0,null,0,0,null,0,0,null,0,0,null,0,null,null,9,null,null,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,null,0,null,0,0,null,0,0,null,0,0,null,0,0,null,0,0,null,0,0,null,0,0,null,0,0,null,0,0,null,null,0,null,0,0,null,0,null,0,0,null,null,0,null,0,null,null,9,0,null,null,9,0,0,null,null,null,null,null,null,null,null,null,null,null]},{"name":"public/app/panels/graph/module.js","source":"define([\n  'angular',\n  'app',\n  'jquery',\n  'lodash',\n  'kbn',\n  'moment',\n  'components/timeSeries',\n  'components/panelmeta',\n  './seriesOverridesCtrl',\n  './graph',\n  './legend',\n],\nfunction (angular, app, $, _, kbn, moment, TimeSeries, PanelMeta) {\n  'use strict';\n\n  var module = angular.module('grafana.panels.graph');\n\n  module.directive('grafanaPanelGraph', function() {\n    return {\n      controller: 'GraphCtrl',\n      templateUrl: 'app/panels/graph/module.html',\n    };\n  });\n\n  module.controller('GraphCtrl', function($scope, $rootScope, panelSrv, annotationsSrv, panelHelper, $q) {\n\n    $scope.panelMeta = new PanelMeta({\n      panelName: 'Graph',\n      editIcon:  \"fa fa-bar-chart\",\n      fullscreen: true,\n      metricsEditor: true,\n    });\n\n    $scope.panelMeta.addEditorTab('Axes & Grid', 'app/panels/graph/axisEditor.html');\n    $scope.panelMeta.addEditorTab('Display Styles', 'app/panels/graph/styleEditor.html');\n    $scope.panelMeta.addEditorTab('Time range', 'app/features/panel/partials/panelTime.html');\n\n    $scope.panelMeta.addExtendedMenuItem('Export CSV', '', 'exportCsv()');\n    $scope.panelMeta.addExtendedMenuItem('Toggle legend', '', 'toggleLegend()');\n\n    // Set and populate defaults\n    var _d = {\n      // datasource name, null = default datasource\n      datasource: null,\n       // sets client side (flot) or native graphite png renderer (png)\n      renderer: 'flot',\n       // Show/hide the x-axis\n      'x-axis'      : true,\n      // Show/hide y-axis\n      'y-axis'      : true,\n      // y axis formats, [left axis,right axis]\n      y_formats    : ['short', 'short'],\n      // grid options\n      grid          : {\n        leftLogBase: 1,\n        leftMax: null,\n        rightMax: null,\n        leftMin: null,\n        rightMin: null,\n        rightLogBase: 1,\n        threshold1: null,\n        threshold2: null,\n        threshold1Color: 'rgba(216, 200, 27, 0.27)',\n        threshold2Color: 'rgba(234, 112, 112, 0.22)'\n      },\n      // show/hide lines\n      lines         : true,\n      // fill factor\n      fill          : 1,\n      // line width in pixels\n      linewidth     : 2,\n      // show hide points\n      points        : false,\n      // point radius in pixels\n      pointradius   : 5,\n      // show hide bars\n      bars          : false,\n      // enable/disable stacking\n      stack         : false,\n      // stack percentage mode\n      percentage    : false,\n      // legend options\n      legend: {\n        show: true, // disable/enable legend\n        values: false, // disable/enable legend values\n        min: false,\n        max: false,\n        current: false,\n        total: false,\n        avg: false\n      },\n      // how null points should be handled\n      nullPointMode : 'connected',\n      // staircase line mode\n      steppedLine: false,\n      // tooltip options\n      tooltip       : {\n        value_type: 'cumulative',\n        shared: true,\n      },\n      // time overrides\n      timeFrom: null,\n      timeShift: null,\n      // metric queries\n      targets: [{}],\n      // series color overrides\n      aliasColors: {},\n      // other style overrides\n      seriesOverrides: [],\n    };\n\n    _.defaults($scope.panel,_d);\n    _.defaults($scope.panel.tooltip, _d.tooltip);\n    _.defaults($scope.panel.annotate, _d.annotate);\n    _.defaults($scope.panel.grid, _d.grid);\n    _.defaults($scope.panel.legend, _d.legend);\n\n    $scope.logScales = {'linear': 1, 'log (base 10)': 10, 'log (base 32)': 32, 'log (base 1024)': 1024};\n\n    $scope.hiddenSeries = {};\n    $scope.seriesList = [];\n    $scope.unitFormats = kbn.getUnitFormats();\n\n    $scope.setUnitFormat = function(axis, subItem) {\n      $scope.panel.y_formats[axis] = subItem.value;\n      $scope.render();\n    };\n\n    $scope.refreshData = function(datasource) {\n      panelHelper.updateTimeRange($scope);\n\n      $scope.annotationsPromise = annotationsSrv.getAnnotations($scope.rangeUnparsed, $scope.dashboard);\n\n      return panelHelper.issueMetricQuery($scope, datasource)\n        .then($scope.dataHandler, function(err) {\n          $scope.seriesList = [];\n          $scope.render([]);\n          throw err;\n        });\n    };\n\n    $scope.loadSnapshot = function(snapshotData) {\n      panelHelper.updateTimeRange($scope);\n      $scope.annotationsPromise = $q.when([]);\n      $scope.dataHandler(snapshotData);\n    };\n\n    $scope.dataHandler = function(results) {\n      // png renderer returns just a url\n      if (_.isString(results)) {\n        $scope.render(results);\n        return;\n      }\n\n      $scope.datapointsWarning = false;\n      $scope.datapointsCount = 0;\n      $scope.datapointsOutside = false;\n\n      $scope.seriesList = _.map(results.data, $scope.seriesHandler);\n\n      $scope.datapointsWarning = $scope.datapointsCount === 0 || $scope.datapointsOutside;\n\n      $scope.annotationsPromise\n        .then(function(annotations) {\n          $scope.panelMeta.loading = false;\n          $scope.seriesList.annotations = annotations;\n          $scope.render($scope.seriesList);\n        }, function() {\n          $scope.panelMeta.loading = false;\n          $scope.render($scope.seriesList);\n        });\n    };\n\n    $scope.seriesHandler = function(seriesData, index) {\n      var datapoints = seriesData.datapoints;\n      var alias = seriesData.target;\n      var color = $scope.panel.aliasColors[alias] || $rootScope.colors[index];\n\n      var series = new TimeSeries({\n        datapoints: datapoints,\n          alias: alias,\n          color: color,\n      });\n\n      if (datapoints && datapoints.length > 0) {\n        var last = moment.utc(datapoints[datapoints.length - 1][1]);\n        var from = moment.utc($scope.range.from);\n        if (last - from < -10000) {\n          $scope.datapointsOutside = true;\n        }\n\n        $scope.datapointsCount += datapoints.length;\n      }\n\n      return series;\n    };\n\n    $scope.render = function(data) {\n      $scope.$broadcast('render', data);\n    };\n\n    $scope.changeSeriesColor = function(series, color) {\n      series.color = color;\n      $scope.panel.aliasColors[series.alias] = series.color;\n      $scope.render();\n    };\n\n    $scope.toggleSeries = function(serie, event) {\n      if (event.ctrlKey || event.metaKey || event.shiftKey) {\n        if ($scope.hiddenSeries[serie.alias]) {\n          delete $scope.hiddenSeries[serie.alias];\n        }\n        else {\n          $scope.hiddenSeries[serie.alias] = true;\n        }\n      } else {\n        $scope.toggleSeriesExclusiveMode(serie);\n      }\n\n      $scope.render();\n    };\n\n    $scope.toggleSeriesExclusiveMode = function(serie) {\n      var hidden = $scope.hiddenSeries;\n\n      if (hidden[serie.alias]) {\n        delete hidden[serie.alias];\n      }\n\n      // check if every other series is hidden\n      var alreadyExclusive = _.every($scope.seriesList, function(value) {\n        if (value.alias === serie.alias) {\n          return true;\n        }\n\n        return hidden[value.alias];\n      });\n\n      if (alreadyExclusive) {\n        // remove all hidden series\n        _.each($scope.seriesList, function(value) {\n          delete $scope.hiddenSeries[value.alias];\n        });\n      }\n      else {\n        // hide all but this serie\n        _.each($scope.seriesList, function(value) {\n          if (value.alias === serie.alias) {\n            return;\n          }\n\n          $scope.hiddenSeries[value.alias] = true;\n        });\n      }\n    };\n\n    $scope.toggleYAxis = function(info) {\n      var override = _.findWhere($scope.panel.seriesOverrides, { alias: info.alias });\n      if (!override) {\n        override = { alias: info.alias };\n        $scope.panel.seriesOverrides.push(override);\n      }\n      override.yaxis = info.yaxis === 2 ? 1 : 2;\n      $scope.render();\n    };\n\n    $scope.addSeriesOverride = function(override) {\n      $scope.panel.seriesOverrides.push(override || {});\n    };\n\n    $scope.removeSeriesOverride = function(override) {\n      $scope.panel.seriesOverrides = _.without($scope.panel.seriesOverrides, override);\n      $scope.render();\n    };\n\n    // Called from panel menu\n    $scope.toggleLegend = function() {\n      $scope.panel.legend.show = !$scope.panel.legend.show;\n      $scope.get_data();\n    };\n\n    $scope.legendValuesOptionChanged = function() {\n      var legend = $scope.panel.legend;\n      legend.values = legend.min || legend.max || legend.avg || legend.current || legend.total;\n      $scope.render();\n    };\n\n    $scope.exportCsv = function() {\n      kbn.exportSeriesListToCsv($scope.seriesList);\n    };\n\n    panelSrv.init($scope);\n\n  });\n\n});\n","coverage":[1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,0,null,null,null,null,null,1,null,1,null,null,null,null,null,null,1,1,1,null,1,1,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,1,1,1,null,1,null,1,1,1,null,1,0,0,null,null,1,1,null,1,null,1,null,0,0,0,null,null,null,1,0,0,0,null,null,1,null,1,0,0,null,null,1,1,1,null,1,null,1,null,1,null,1,1,1,null,0,0,null,null,null,1,2,2,2,null,2,null,null,null,null,null,2,2,2,2,2,null,null,2,null,null,2,null,null,1,0,null,null,1,0,0,0,null,null,1,0,0,0,null,null,0,null,null,0,null,null,0,null,null,1,0,null,0,0,null,null,null,0,0,0,null,null,0,null,null,0,null,0,0,null,null,null,null,0,0,0,null,null,0,null,null,null,null,1,0,0,0,0,null,0,0,null,null,1,0,null,null,1,0,0,null,null,null,1,0,0,null,null,1,0,0,0,null,null,1,0,null,null,1,null,null,null,null,null]},{"name":"public/app/panels/graph/seriesOverridesCtrl.js","source":"define([\n  'angular',\n  'app',\n  'lodash',\n], function(angular, app, _) {\n  'use strict';\n\n  var module = angular.module('grafana.panels.graph', []);\n  app.useModule(module);\n\n  module.controller('SeriesOverridesCtrl', function($scope) {\n    $scope.overrideMenu = [];\n    $scope.currentOverrides = [];\n    $scope.override = $scope.override || {};\n\n    $scope.addOverrideOption = function(name, propertyName, values) {\n      var option = {};\n      option.text = name;\n      option.propertyName = propertyName;\n      option.index = $scope.overrideMenu.length;\n      option.values = values;\n\n      option.submenu = _.map(values, function(value) {\n        return { text: String(value), value: value };\n      });\n\n      $scope.overrideMenu.push(option);\n    };\n\n    $scope.setOverride = function(item, subItem) {\n      $scope.override[item.propertyName] = subItem.value;\n\n      // automatically disable lines for this series and the fill bellow to series\n      // can be removed by the user if they still want lines\n      if (item.propertyName === 'fillBelowTo') {\n        $scope.override['lines'] = false;\n        $scope.addSeriesOverride({ alias: subItem.value, lines: false });\n      }\n\n      $scope.updateCurrentOverrides();\n      $scope.render();\n    };\n\n    $scope.removeOverride = function(option) {\n      delete $scope.override[option.propertyName];\n      $scope.updateCurrentOverrides();\n      $scope.render();\n    };\n\n    $scope.getSeriesNames = function() {\n      return _.map($scope.seriesList, function(series) {\n        return series.alias;\n      });\n    };\n\n    $scope.updateCurrentOverrides = function() {\n      $scope.currentOverrides = [];\n      _.each($scope.overrideMenu, function(option) {\n        var value = $scope.override[option.propertyName];\n        if (_.isUndefined(value)) { return; }\n        $scope.currentOverrides.push({\n          name: option.text,\n          propertyName: option.propertyName,\n          value: String(value)\n        });\n      });\n    };\n\n    $scope.addOverrideOption('Bars', 'bars', [true, false]);\n    $scope.addOverrideOption('Lines', 'lines', [true, false]);\n    $scope.addOverrideOption('Line fill', 'fill', [0,1,2,3,4,5,6,7,8,9,10]);\n    $scope.addOverrideOption('Line width', 'linewidth', [0,1,2,3,4,5,6,7,8,9,10]);\n    $scope.addOverrideOption('Fill below to', 'fillBelowTo', $scope.getSeriesNames());\n    $scope.addOverrideOption('Staircase line', 'steppedLine', [true, false]);\n    $scope.addOverrideOption('Points', 'points', [true, false]);\n    $scope.addOverrideOption('Points Radius', 'pointradius', [1,2,3,4,5]);\n    $scope.addOverrideOption('Stack', 'stack', [true, false, 2, 3, 4, 5]);\n    $scope.addOverrideOption('Y-axis', 'yaxis', [1, 2]);\n    $scope.addOverrideOption('Z-index', 'zindex', [-1,-2,-3,0,1,2,3]);\n    $scope.updateCurrentOverrides();\n\n  });\n\n});\n","coverage":[1,null,null,null,null,null,null,1,1,null,1,3,3,3,null,3,33,33,33,33,33,null,33,150,null,null,33,null,null,3,3,null,null,null,3,0,0,null,null,3,3,null,null,3,1,1,1,null,null,3,3,0,null,null,null,3,7,7,77,77,2,null,null,null,null,null,null,null,3,3,3,3,3,3,3,3,3,3,3,3,null,null,null,null,null]},{"name":"public/app/features/dashboard/timeSrv.js","source":"define([\n  'angular',\n  'lodash',\n  'config',\n  'kbn',\n  'moment'\n], function (angular, _, config, kbn, moment) {\n  'use strict';\n\n  var module = angular.module('grafana.services');\n\n  module.service('timeSrv', function($rootScope, $timeout, $routeParams, timer) {\n    var self = this;\n\n    this.init = function(dashboard) {\n      timer.cancel_all();\n\n      this.dashboard = dashboard;\n      this.time = dashboard.time;\n\n      this._initTimeFromUrl();\n      this._parseTime();\n\n      if(this.dashboard.refresh) {\n        this.set_interval(this.dashboard.refresh);\n      }\n    };\n\n    this._parseTime = function() {\n      // when absolute time is saved in json it is turned to a string\n      if (_.isString(this.time.from) && this.time.from.indexOf('Z') >= 0) {\n        this.time.from = new Date(this.time.from);\n      }\n      if (_.isString(this.time.to) && this.time.to.indexOf('Z') >= 0) {\n        this.time.to = new Date(this.time.to);\n      }\n    };\n\n    this._parseUrlParam = function(value) {\n      if (value.indexOf('now') !== -1) {\n        return value;\n      }\n      if (value.length === 8) {\n        return moment.utc(value, 'YYYYMMDD').toDate();\n      }\n      if (value.length === 15) {\n        return moment.utc(value, 'YYYYMMDDTHHmmss').toDate();\n      }\n      var epoch = parseInt(value);\n      if (!_.isNaN(epoch)) {\n        return new Date(epoch);\n      }\n\n      return null;\n    };\n\n    this._initTimeFromUrl = function() {\n      if ($routeParams.from) {\n        this.time.from = this._parseUrlParam($routeParams.from) || this.time.from;\n      }\n      if ($routeParams.to) {\n        this.time.to = this._parseUrlParam($routeParams.to) || this.time.to;\n      }\n    };\n\n    this.set_interval = function (interval) {\n      this.dashboard.refresh = interval;\n      if (interval) {\n        var _i = kbn.interval_to_ms(interval);\n        this.start_scheduled_refresh(_i);\n      } else {\n        this.cancel_scheduled_refresh();\n      }\n    };\n\n    this.refreshDashboard = function() {\n      $rootScope.$broadcast('refresh');\n    };\n\n    this.start_scheduled_refresh = function (after_ms) {\n      self.cancel_scheduled_refresh();\n      self.refresh_timer = timer.register($timeout(function () {\n        self.start_scheduled_refresh(after_ms);\n        self.refreshDashboard();\n      }, after_ms));\n    };\n\n    this.cancel_scheduled_refresh = function () {\n      timer.cancel(this.refresh_timer);\n    };\n\n    this.setTime = function(time) {\n      _.extend(this.time, time);\n\n      // disable refresh if we have an absolute time\n      if (time.to !== 'now') {\n        this.old_refresh = this.dashboard.refresh || this.old_refresh;\n        this.set_interval(false);\n      }\n      else if (this.old_refresh && this.old_refresh !== this.dashboard.refresh) {\n        this.set_interval(this.old_refresh);\n        this.old_refresh = null;\n      }\n\n      $rootScope.appEvent('time-range-changed', this.time);\n      $timeout(this.refreshDashboard, 0);\n    };\n\n    this.timeRangeForUrl = function() {\n      var range = this.timeRange(false);\n      if (_.isString(range.to) && range.to.indexOf('now')) {\n        range = this.timeRange();\n      }\n\n      if (_.isDate(range.from)) { range.from = range.from.getTime(); }\n      if (_.isDate(range.to)) { range.to = range.to.getTime(); }\n\n      return range;\n    };\n\n    this.timeRange = function(parse) {\n      var _t = this.time;\n\n      if(parse === false) {\n        return {\n          from: _t.from,\n          to: _t.to\n        };\n      } else {\n        var _from = _t.from;\n        var _to = _t.to || new Date();\n\n        return {\n          from: kbn.parseDate(_from),\n          to: kbn.parseDate(_to)\n        };\n      }\n    };\n\n  });\n\n});\n","coverage":[1,null,null,null,null,null,null,null,null,1,null,1,8,null,8,12,null,12,12,null,12,12,null,12,12,null,null,null,8,null,12,0,null,12,0,null,null,null,8,18,4,null,14,4,null,10,4,null,6,6,6,null,null,0,null,null,8,12,9,null,12,9,null,null,null,8,17,17,13,13,null,4,null,null,null,8,0,null,null,8,13,13,0,0,null,null,null,8,17,null,null,8,5,null,null,5,4,4,null,1,1,1,null,null,5,5,null,null,8,0,0,0,null,null,0,0,null,0,null,null,8,6,null,6,2,null,null,null,null,4,4,null,4,null,null,null,null,null,null,null,null,null,null]},{"name":"public/app/components/kbn.js","source":"define([\n  'jquery',\n  'lodash',\n  'moment'\n],\nfunction($, _, moment) {\n  'use strict';\n\n  var kbn = {};\n  kbn.valueFormats = {};\n\n  kbn.round_interval = function(interval) {\n    switch (true) {\n    // 0.5s\n    case (interval <= 500):\n      return 100;       // 0.1s\n    // 5s\n    case (interval <= 5000):\n      return 1000;      // 1s\n    // 7.5s\n    case (interval <= 7500):\n      return 5000;      // 5s\n    // 15s\n    case (interval <= 15000):\n      return 10000;     // 10s\n    // 45s\n    case (interval <= 45000):\n      return 30000;     // 30s\n    // 3m\n    case (interval <= 180000):\n      return 60000;     // 1m\n    // 9m\n    case (interval <= 450000):\n      return 300000;    // 5m\n    // 20m\n    case (interval <= 1200000):\n      return 600000;    // 10m\n    // 45m\n    case (interval <= 2700000):\n      return 1800000;   // 30m\n    // 2h\n    case (interval <= 7200000):\n      return 3600000;   // 1h\n    // 6h\n    case (interval <= 21600000):\n      return 10800000;  // 3h\n    // 24h\n    case (interval <= 86400000):\n      return 43200000;  // 12h\n    // 48h\n    case (interval <= 172800000):\n      return 86400000;  // 24h\n    // 1w\n    case (interval <= 604800000):\n      return 86400000;  // 24h\n    // 3w\n    case (interval <= 1814400000):\n      return 604800000; // 1w\n    // 2y\n    case (interval < 3628800000):\n      return 2592000000; // 30d\n    default:\n      return 31536000000; // 1y\n    }\n  };\n\n  kbn.secondsToHms = function(seconds) {\n    var numyears = Math.floor(seconds / 31536000);\n    if(numyears){\n      return numyears + 'y';\n    }\n    var numdays = Math.floor((seconds % 31536000) / 86400);\n    if(numdays){\n      return numdays + 'd';\n    }\n    var numhours = Math.floor(((seconds % 31536000) % 86400) / 3600);\n    if(numhours){\n      return numhours + 'h';\n    }\n    var numminutes = Math.floor((((seconds % 31536000) % 86400) % 3600) / 60);\n    if(numminutes){\n      return numminutes + 'm';\n    }\n    var numseconds = (((seconds % 31536000) % 86400) % 3600) % 60;\n    if(numseconds){\n      return numseconds + 's';\n    }\n    return 'less then a second'; //'just now' //or other string you like;\n  };\n\n  kbn.to_percent = function(number,outof) {\n    return Math.floor((number/outof)*10000)/100 + \"%\";\n  };\n\n  kbn.addslashes = function(str) {\n    str = str.replace(/\\\\/g, '\\\\\\\\');\n    str = str.replace(/\\'/g, '\\\\\\'');\n    str = str.replace(/\\\"/g, '\\\\\"');\n    str = str.replace(/\\0/g, '\\\\0');\n    return str;\n  };\n\n  kbn.interval_regex = /(\\d+(?:\\.\\d+)?)([Mwdhmsy])/;\n\n  // histogram & trends\n  kbn.intervals_in_seconds = {\n    y: 31536000,\n    M: 2592000,\n    w: 604800,\n    d: 86400,\n    h: 3600,\n    m: 60,\n    s: 1\n  };\n\n  kbn.calculateInterval = function(range, resolution, userInterval) {\n    var lowLimitMs = 1; // 1 millisecond default low limit\n    var intervalMs, lowLimitInterval;\n\n    if (userInterval) {\n      if (userInterval[0] === '>') {\n        lowLimitInterval = userInterval.slice(1);\n        lowLimitMs = kbn.interval_to_ms(lowLimitInterval);\n      }\n      else {\n        return userInterval;\n      }\n    }\n\n    intervalMs = kbn.round_interval((range.to.valueOf() - range.from.valueOf()) / resolution);\n    if (lowLimitMs > intervalMs) {\n      intervalMs = lowLimitMs;\n    }\n\n    return kbn.secondsToHms(intervalMs / 1000);\n  };\n\n  kbn.describe_interval = function (string) {\n    var matches = string.match(kbn.interval_regex);\n    if (!matches || !_.has(kbn.intervals_in_seconds, matches[2])) {\n      throw new Error('Invalid interval string, expexcting a number followed by one of \"Mwdhmsy\"');\n    } else {\n      return {\n        sec: kbn.intervals_in_seconds[matches[2]],\n        type: matches[2],\n        count: parseInt(matches[1], 10)\n      };\n    }\n  };\n\n  kbn.interval_to_ms = function(string) {\n    var info = kbn.describe_interval(string);\n    return info.sec * 1000 * info.count;\n  };\n\n  kbn.interval_to_seconds = function (string) {\n    var info = kbn.describe_interval(string);\n    return info.sec * info.count;\n  };\n\n  /* This is a simplified version of elasticsearch's date parser */\n  kbn.parseDate = function(text) {\n    if(_.isDate(text)) {\n      return text;\n    }\n\n    var time;\n    var mathString = \"\";\n    var index;\n    var parseString;\n\n    if (text.substring(0,3) === \"now\") {\n      time = new Date();\n      mathString = text.substring(3);\n    }\n    else if (text.substring(0,5) === 'today') {\n      time = new Date();\n      time.setHours(0,0,0,0);\n      mathString = text.substring(5);\n    }\n    else {\n      index = text.indexOf(\"||\");\n      parseString;\n      if (index === -1) {\n        parseString = text;\n        mathString = \"\"; // nothing else\n      } else {\n        parseString = text.substring(0, index);\n        mathString = text.substring(index + 2);\n      }\n      // We're going to just require ISO8601 timestamps, k?\n      time = new Date(parseString);\n    }\n\n    if (!mathString.length) {\n      return time;\n    }\n\n    //return [time,parseString,mathString];\n    return kbn.parseDateMath(mathString, time);\n  };\n\n  kbn._timespanRegex = /^\\d+[h,m,M,w,s,H,d]$/;\n  kbn.isValidTimeSpan = function(str) {\n    return kbn._timespanRegex.test(str);\n  };\n\n  kbn.parseDateMath = function(mathString, time, roundUp) {\n    var dateTime = moment(time);\n    for (var i = 0; i < mathString.length;) {\n      var c = mathString.charAt(i++),\n        type,\n        num,\n        unit;\n      if (c === '/') {\n        type = 0;\n      } else if (c === '+') {\n        type = 1;\n      } else if (c === '-') {\n        type = 2;\n      } else {\n        return false;\n      }\n\n      if (isNaN(mathString.charAt(i))) {\n        num = 1;\n      } else {\n        var numFrom = i;\n        while (!isNaN(mathString.charAt(i))) {\n          i++;\n        }\n        num = parseInt(mathString.substring(numFrom, i),10);\n      }\n      if (type === 0) {\n        // rounding is only allowed on whole numbers\n        if (num !== 1) {\n          return false;\n        }\n      }\n      unit = mathString.charAt(i++);\n      switch (unit) {\n      case 'y':\n        if (type === 0) {\n          roundUp ? dateTime.endOf('year') : dateTime.startOf('year');\n        } else if (type === 1) {\n          dateTime.add(num, 'years');\n        } else if (type === 2) {\n          dateTime.subtract(num, 'years');\n        }\n        break;\n      case 'M':\n        if (type === 0) {\n          roundUp ? dateTime.endOf('month') : dateTime.startOf('month');\n        } else if (type === 1) {\n          dateTime.add(num, 'months');\n        } else if (type === 2) {\n          dateTime.subtract(num, 'months');\n        }\n        break;\n      case 'w':\n        if (type === 0) {\n          roundUp ? dateTime.endOf('week') : dateTime.startOf('week');\n        } else if (type === 1) {\n          dateTime.add(num, 'weeks');\n        } else if (type === 2) {\n          dateTime.subtract(num, 'weeks');\n        }\n        break;\n      case 'd':\n        if (type === 0) {\n          roundUp ? dateTime.endOf('day') : dateTime.startOf('day');\n        } else if (type === 1) {\n          dateTime.add(num, 'days');\n        } else if (type === 2) {\n          dateTime.subtract(num, 'days');\n        }\n        break;\n      case 'h':\n      case 'H':\n        if (type === 0) {\n          roundUp ? dateTime.endOf('hour') : dateTime.startOf('hour');\n        } else if (type === 1) {\n          dateTime.add(num, 'hours');\n        } else if (type === 2) {\n          dateTime.subtract(num,'hours');\n        }\n        break;\n      case 'm':\n        if (type === 0) {\n          roundUp ? dateTime.endOf('minute') : dateTime.startOf('minute');\n        } else if (type === 1) {\n          dateTime.add(num, 'minutes');\n        } else if (type === 2) {\n          dateTime.subtract(num, 'minutes');\n        }\n        break;\n      case 's':\n        if (type === 0) {\n          roundUp ? dateTime.endOf('second') : dateTime.startOf('second');\n        } else if (type === 1) {\n          dateTime.add(num, 'seconds');\n        } else if (type === 2) {\n          dateTime.subtract(num, 'seconds');\n        }\n        break;\n      default:\n        return false;\n      }\n    }\n    return dateTime.toDate();\n  };\n\n  kbn.query_color_dot = function (color, diameter) {\n    return '<div class=\"icon-circle\" style=\"' + [\n      'display:inline-block',\n      'color:' + color,\n      'font-size:' + diameter + 'px',\n    ].join(';') + '\"></div>';\n  };\n\n  kbn.valueFormats.percent = function(size, decimals) {\n    return kbn.toFixed(size, decimals) + '%';\n  };\n\n  kbn.formatFuncCreator = function(factor, extArray) {\n    return function(size, decimals, scaledDecimals) {\n      if (size === null) {\n        return \"\";\n      }\n\n      var steps = 0;\n      var limit = extArray.length;\n\n      while (Math.abs(size) >= factor) {\n        steps++;\n        size /= factor;\n\n        if (steps >= limit) { return \"NA\"; }\n      }\n\n      if (steps > 0 && scaledDecimals !== null) {\n        decimals = scaledDecimals + (3 * steps);\n      }\n\n      return kbn.toFixed(size, decimals) + extArray[steps];\n    };\n  };\n\n  kbn.toFixed = function(value, decimals) {\n    if (value === null) {\n      return \"\";\n    }\n\n    var factor = decimals ? Math.pow(10, Math.max(0, decimals)) : 1;\n    var formatted = String(Math.round(value * factor) / factor);\n\n    // if exponent return directly\n    if (formatted.indexOf('e') !== -1 || value === 0) {\n      return formatted;\n    }\n\n    // If tickDecimals was specified, ensure that we have exactly that\n    // much precision; otherwise default to the value's own precision.\n    if (decimals != null) {\n      var decimalPos = formatted.indexOf(\".\");\n      var precision = decimalPos === -1 ? 0 : formatted.length - decimalPos - 1;\n      if (precision < decimals) {\n        return (precision ? formatted : formatted + \".\") + (String(factor)).substr(1, decimals - precision);\n      }\n    }\n\n    return formatted;\n  };\n\n  kbn.valueFormats.bits = kbn.formatFuncCreator(1024, [' b', ' Kib', ' Mib', ' Gib', ' Tib', ' Pib', ' Eib', ' Zib', ' Yib']);\n  kbn.valueFormats.bytes = kbn.formatFuncCreator(1024, [' B', ' KiB', ' MiB', ' GiB', ' TiB', ' PiB', ' EiB', ' ZiB', ' YiB']);\n  kbn.valueFormats.kbytes = kbn.formatFuncCreator(1024, [' KiB', ' MiB', ' GiB', ' TiB', ' PiB', ' EiB', ' ZiB', ' YiB']);\n  kbn.valueFormats.mbytes = kbn.formatFuncCreator(1024, [' MiB', ' GiB', ' TiB', ' PiB', ' EiB', ' ZiB', ' YiB']);\n  kbn.valueFormats.gbytes = kbn.formatFuncCreator(1024, [' GiB', ' TiB', ' PiB', ' EiB', ' ZiB', ' YiB']);\n  kbn.valueFormats.bps = kbn.formatFuncCreator(1000, [' bps', ' Kbps', ' Mbps', ' Gbps', ' Tbps', ' Pbps', ' Ebps', ' Zbps', ' Ybps']);\n  kbn.valueFormats.Bps = kbn.formatFuncCreator(1000, [' Bps', ' KBps', ' MBps', ' GBps', ' TBps', ' PBps', ' EBps', ' ZBps', ' YBps']);\n  kbn.valueFormats.short = kbn.formatFuncCreator(1000, ['', ' K', ' Mil', ' Bil', ' Tri', ' Qaudr', ' Quint', ' Sext', ' Sept']);\n  kbn.valueFormats.joule = kbn.formatFuncCreator(1000, [' J', ' kJ', ' MJ', ' GJ', ' TJ', ' PJ', ' EJ', ' ZJ', ' YJ']);\n  kbn.valueFormats.amp = kbn.formatFuncCreator(1000, [' A', ' kA', ' MA', ' GA', ' TA', ' PA', ' EA', ' ZA', ' YA']);\n  kbn.valueFormats.volt = kbn.formatFuncCreator(1000, [' V', ' kV', ' MV', ' GV', ' TV', ' PV', ' EV', ' ZV', ' YV']);\n  kbn.valueFormats.hertz = kbn.formatFuncCreator(1000, [' Hz', ' kHz', ' MHz', ' GHz', ' THz', ' PHz', ' EHz', ' ZHz', ' YHz']);\n  kbn.valueFormats.watt = kbn.formatFuncCreator(1000, [' W', ' kW', ' MW', ' GW', ' TW', ' PW', ' EW', ' ZW', ' YW']);\n  kbn.valueFormats.kwatt = kbn.formatFuncCreator(1000, [' kW', ' MW', ' GW', ' TW', ' PW', ' EW', ' ZW', ' YW']);\n  kbn.valueFormats.watth = kbn.formatFuncCreator(1000, [' Wh', ' kWh', ' MWh', ' GWh', ' TWh', ' PWh', ' EWh', ' ZWh', ' YWh']);\n  kbn.valueFormats.kwatth = kbn.formatFuncCreator(1000, [' kWh', ' MWh', ' GWh', ' TWh', ' PWh', ' EWh', ' ZWh', ' YWh']);\n  kbn.valueFormats.ev = kbn.formatFuncCreator(1000, [' eV', ' keV', ' MeV', 'GeV', 'TeV', 'PeV', 'EeV', 'ZeV', 'YeV']);\n  kbn.valueFormats.none = kbn.toFixed;\n  kbn.valueFormats.celsius = function(value, decimals) { return kbn.toFixed(value, decimals) + ' C'; };\n  kbn.valueFormats.farenheit = function(value, decimals) { return kbn.toFixed(value, decimals) + ' F'; };\n  kbn.valueFormats.humidity = function(value, decimals) { return kbn.toFixed(value, decimals) + ' %H'; };\n  kbn.valueFormats.ppm = function(value, decimals) { return kbn.toFixed(value, decimals) + ' ppm'; };\n  kbn.valueFormats.velocityms = function(value, decimals) { return kbn.toFixed(value, decimals) + ' m/s'; };\n  kbn.valueFormats.velocitykmh = function(value, decimals) { return kbn.toFixed(value, decimals) + ' km/h'; };\n  kbn.valueFormats.velocitymph = function(value, decimals) { return kbn.toFixed(value, decimals) + ' mph'; };\n  kbn.valueFormats.velocityknot = function(value, decimals) { return kbn.toFixed(value, decimals) + ' kn'; };\n\n  kbn.toFixedScaled = function(value, decimals, scaledDecimals, additionalDecimals, ext) {\n    if (scaledDecimals === null) {\n      return kbn.toFixed(value, decimals) + ext;\n    } else {\n      return kbn.toFixed(value, scaledDecimals + additionalDecimals) + ext;\n    }\n  };\n\n  kbn.valueFormats.ms = function(size, decimals, scaledDecimals) {\n    if (size === null) { return \"\"; }\n\n    if (Math.abs(size) < 1000) {\n      return kbn.toFixed(size, decimals) + \" ms\";\n    }\n    // Less than 1 min\n    else if (Math.abs(size) < 60000) {\n      return kbn.toFixedScaled(size / 1000, decimals, scaledDecimals, 3, \" s\");\n    }\n    // Less than 1 hour, devide in minutes\n    else if (Math.abs(size) < 3600000) {\n      return kbn.toFixedScaled(size / 60000, decimals, scaledDecimals, 5, \" min\");\n    }\n    // Less than one day, devide in hours\n    else if (Math.abs(size) < 86400000) {\n      return kbn.toFixedScaled(size / 3600000, decimals, scaledDecimals, 7, \" hour\");\n    }\n    // Less than one year, devide in days\n    else if (Math.abs(size) < 31536000000) {\n      return kbn.toFixedScaled(size / 86400000, decimals, scaledDecimals, 8, \" day\");\n    }\n\n    return kbn.toFixedScaled(size / 31536000000, decimals, scaledDecimals, 10, \" year\");\n  };\n\n  kbn.valueFormats.s = function(size, decimals, scaledDecimals) {\n    if (size === null) { return \"\"; }\n\n    if (Math.abs(size) < 600) {\n      return kbn.toFixed(size, decimals) + \" s\";\n    }\n    // Less than 1 hour, devide in minutes\n    else if (Math.abs(size) < 3600) {\n      return kbn.toFixedScaled(size / 60, decimals, scaledDecimals, 1, \" min\");\n    }\n    // Less than one day, devide in hours\n    else if (Math.abs(size) < 86400) {\n      return kbn.toFixedScaled(size / 3600, decimals, scaledDecimals, 4, \" hour\");\n    }\n    // Less than one week, devide in days\n    else if (Math.abs(size) < 604800) {\n      return kbn.toFixedScaled(size / 86400, decimals, scaledDecimals, 5, \" day\");\n    }\n    // Less than one year, devide in week\n    else if (Math.abs(size) < 31536000) {\n      return kbn.toFixedScaled(size / 604800, decimals, scaledDecimals, 6, \" week\");\n    }\n\n    return kbn.toFixedScaled(size / 3.15569e7, decimals, scaledDecimals, 7, \" year\");\n  };\n\n  kbn.valueFormats['s'] = function(size, decimals, scaledDecimals) {\n    if (size === null) { return \"\"; }\n\n    if (Math.abs(size) < 1000) {\n      return kbn.toFixed(size, decimals) + \" s\";\n    }\n    else if (Math.abs(size) < 1000000) {\n      return kbn.toFixedScaled(size / 1000, decimals, scaledDecimals, 3, \" ms\");\n    }\n    else {\n      return kbn.toFixedScaled(size / 1000000, decimals, scaledDecimals, 6, \" s\");\n    }\n  };\n\n  kbn.valueFormats.ns = function(size, decimals, scaledDecimals) {\n    if (size === null) { return \"\"; }\n\n    if (Math.abs(size) < 1000) {\n      return kbn.toFixed(size, decimals) + \" ns\";\n    }\n    else if (Math.abs(size) < 1000000) {\n      return kbn.toFixedScaled(size / 1000, decimals, scaledDecimals, 3, \" s\");\n    }\n    else if (Math.abs(size) < 1000000000) {\n      return kbn.toFixedScaled(size / 1000000, decimals, scaledDecimals, 6, \" ms\");\n    }\n    else if (Math.abs(size) < 60000000000){\n      return kbn.toFixedScaled(size / 1000000000, decimals, scaledDecimals, 9, \" s\");\n    }\n    else {\n      return kbn.toFixedScaled(size / 60000000000, decimals, scaledDecimals, 12, \" min\");\n    }\n  };\n\n  kbn.slugifyForUrl = function(str) {\n    return str\n      .toLowerCase()\n      .replace(/[^\\w ]+/g,'')\n      .replace(/ +/g,'-');\n  };\n\n  kbn.exportSeriesListToCsv = function(seriesList) {\n    var text = 'Series;Time;Value\\n';\n    _.each(seriesList, function(series) {\n      _.each(series.datapoints, function(dp) {\n        text += series.alias + ';' + new Date(dp[1]).toISOString() + ';' + dp[0] + '\\n';\n      });\n    });\n    var blob = new Blob([text], { type: \"text/csv;charset=utf-8\" });\n    window.saveAs(blob, 'grafana_data_export.csv');\n  };\n\n  kbn.stringToJsRegex = function(str) {\n    if (str[0] !== '/') {\n      return new RegExp(str);\n    }\n\n    var match = str.match(new RegExp('^/(.*?)/(g?i?m?y?)$'));\n    return new RegExp(match[1], match[2]);\n  };\n\n  kbn.getUnitFormats = function() {\n    return [\n      {\n        text: 'none',\n        submenu: [\n          {text: 'none' , value: 'none'},\n          {text: 'short', value: 'short'},\n          {text: 'percent', value: 'percent'},\n          {text: 'ppm', value: 'ppm'},\n        ]\n      },\n      {\n        text: 'duration',\n        submenu: [\n          {text: 'nanoseconds (ns)' , value: 'ns'},\n          {text: 'microseconds (s)', value: 's'},\n          {text: 'milliseconds (ms)', value: 'ms'},\n          {text: 'seconds (s)', value: 's'},\n          {text: 'Hertz (1/s)', value: 'hertz'},\n        ]\n      },\n      {\n        text: 'data',\n        submenu: [\n          {text: 'bits', value: 'bits'},\n          {text: 'bytes', value: 'bytes'},\n          {text: 'kilobytes', value: 'kbytes'},\n          {text: 'megabytes', value: 'mbytes'},\n          {text: 'gigabytes', value: 'gbytes'},\n        ]\n      },\n      {\n        text: 'data rate',\n        submenu: [\n          {text: 'bits/sec', value: 'bps'},\n          {text: 'bytes/sec', value: 'Bps'},\n        ]\n      },\n      {\n        text: 'energy',\n        submenu: [\n          {text: 'watt (W)',              value: 'watt'},\n          {text: 'kilowatt (kW)',         value: 'kwatt'},\n          {text: 'watt-hour (Wh)',        value: 'watth'},\n          {text: 'kilowatt-hour (kWh)',   value: 'kwatth'},\n          {text: 'joule (J)',             value: 'joule'},\n          {text: 'electron volt (eV)',    value: 'ev'},\n          {text: 'Ampere (A)',            value: 'amp'},\n          {text: 'Volt (V)',              value: 'volt'},\n        ]\n      },\n      {\n        text: 'weather',\n        submenu: [\n          {text: 'Celcius (C)',         value: 'celsius'  },\n          {text: 'Farenheit (F)',       value: 'farenheit'},\n          {text: 'Humidity (%H)',        value: 'humidity' },\n        ]\n      },\n      {\n        text: 'velocity',\n        submenu: [\n          {text: 'm/s',  value: 'velocityms'  },\n          {text: 'km/h', value: 'velocitykmh'  },\n          {text: 'mph',  value: 'velocitymph'  },\n          {text: 'knot (kn)', value: 'velocityknot'  },\n        ]\n      },\n    ];\n  };\n\n  return kbn;\n});\n","coverage":[1,null,null,null,null,null,null,null,1,1,null,1,7,null,null,2,null,null,0,null,null,0,null,null,1,null,null,1,null,null,0,null,null,0,null,null,0,null,null,1,null,null,0,null,null,0,null,null,2,null,null,0,null,null,0,null,null,0,null,null,0,null,0,null,null,null,1,7,7,0,null,7,7,0,null,7,7,2,null,5,5,1,null,4,4,4,null,0,null,null,1,0,null,null,1,0,0,0,0,0,null,null,1,null,null,1,null,null,null,null,null,null,null,null,null,1,8,8,null,8,3,2,2,null,null,1,null,null,null,7,7,1,null,null,7,null,null,1,15,15,0,null,15,null,null,null,null,null,null,null,1,15,15,null,null,1,0,0,null,null,null,1,20,6,null,null,14,14,14,14,null,14,14,14,null,0,0,0,0,null,null,0,0,0,0,0,null,0,0,null,null,0,null,null,14,7,null,null,null,7,null,null,1,1,0,null,null,1,10,10,11,null,null,null,11,0,11,0,11,10,null,1,null,null,10,0,null,10,10,14,null,10,null,10,null,0,0,null,null,10,10,null,0,0,0,0,0,0,null,0,null,0,0,0,0,0,0,null,0,null,0,0,0,0,0,0,null,0,null,3,0,3,0,3,3,null,3,null,null,4,0,4,0,4,4,null,4,null,3,0,3,0,3,3,null,3,null,0,0,0,0,0,0,null,0,null,0,null,null,9,null,null,1,0,null,null,null,null,null,null,1,0,null,null,1,17,2,0,null,null,2,2,null,2,11,11,null,11,null,null,1,0,null,null,1,null,null,null,1,14,0,null,null,14,14,null,null,14,2,null,null,null,null,12,12,12,12,0,null,null,null,12,null,null,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,null,1,7,1,null,6,null,null,null,1,8,null,8,2,null,null,6,2,null,null,4,1,null,null,3,2,null,null,1,1,null,null,0,null,null,1,0,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,null,null,1,0,null,0,0,null,0,0,null,null,0,null,null,null,1,2,null,2,1,null,1,1,null,0,0,null,0,0,null,null,0,null,null,null,1,0,null,null,null,null,null,1,0,0,0,0,null,null,0,0,null,null,1,5,2,null,null,3,3,null,null,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null]},{"name":"public/app/panels/graph/graph.tooltip.js","source":"define([\n  'jquery',\n],\nfunction ($) {\n  'use strict';\n\n  function GraphTooltip(elem, dashboard, scope, getSeriesFn) {\n    var self = this;\n\n    var $tooltip = $('<div id=\"tooltip\">');\n\n    this.findHoverIndexFromDataPoints = function(posX, series, last) {\n      var ps = series.datapoints.pointsize;\n      var initial = last*ps;\n      var len = series.datapoints.points.length;\n      for (var j = initial; j < len; j += ps) {\n        if (series.datapoints.points[j] > posX) {\n          return Math.max(j - ps,  0)/ps;\n        }\n      }\n      return j/ps - 1;\n    };\n\n    this.findHoverIndexFromData = function(posX, series) {\n      var len = series.data.length;\n      for (var j = 0; j < len; j++) {\n        if (series.data[j][0] > posX) {\n          return Math.max(j - 1,  0);\n        }\n      }\n      return j - 1;\n    };\n\n    this.showTooltip = function(title, innerHtml, pos) {\n      var body = '<div class=\"graph-tooltip small\"><div class=\"graph-tooltip-time\">'+ title + '</div> ' ;\n      body += innerHtml + '</div>';\n      $tooltip.html(body).place_tt(pos.pageX + 20, pos.pageY);\n    };\n\n    this.getMultiSeriesPlotHoverInfo = function(seriesList, pos) {\n      var value, i, series, hoverIndex;\n      var results = [];\n\n      //now we know the current X (j) position for X and Y values\n      var last_value = 0; //needed for stacked values\n\n      for (i = 0; i < seriesList.length; i++) {\n        series = seriesList[i];\n\n        if (!series.data.length || (scope.panel.legend.hideEmpty && series.allIsNull)) {\n          results.push({ hidden: true });\n          continue;\n        }\n\n        hoverIndex = this.findHoverIndexFromData(pos.x, series);\n        results.time = series.data[hoverIndex][0];\n\n        if (scope.panel.stack) {\n          if (scope.panel.tooltip.value_type === 'individual') {\n            value = series.data[hoverIndex][1];\n          } else {\n            last_value += series.data[hoverIndex][1];\n            value = last_value;\n          }\n        } else {\n          value = series.data[hoverIndex][1];\n        }\n\n        // Highlighting multiple Points depending on the plot type\n        if (scope.panel.steppedLine || (scope.panel.stack && scope.panel.nullPointMode == \"null\")) {\n          // stacked and steppedLine plots can have series with different length.\n          // Stacked series can increase its length on each new stacked serie if null points found,\n          // to speed the index search we begin always on the last found hoverIndex.\n          var newhoverIndex = this.findHoverIndexFromDataPoints(pos.x, series, hoverIndex);\n          results.push({ value: value, hoverIndex: newhoverIndex});\n        } else {\n          results.push({ value: value, hoverIndex: hoverIndex});\n        }\n      }\n\n      return results;\n    };\n\n    elem.mouseleave(function () {\n      if (scope.panel.tooltip.shared) {\n        var plot = elem.data().plot;\n        if (plot) {\n          $tooltip.detach();\n          plot.unhighlight();\n        }\n      }\n\n      if (dashboard.sharedCrosshair) {\n        scope.appEvent('clearCrosshair');\n      }\n    });\n\n    elem.bind(\"plothover\", function (event, pos, item) {\n      var plot = elem.data().plot;\n      var plotData = plot.getData();\n      var seriesList = getSeriesFn();\n      var group, value, timestamp, hoverInfo, i, series, seriesHtml;\n\n      if(dashboard.sharedCrosshair){\n        scope.appEvent('setCrosshair', { pos: pos, scope: scope });\n      }\n\n      if (seriesList.length === 0) {\n        return;\n      }\n\n      if (scope.panel.tooltip.shared) {\n        plot.unhighlight();\n\n        var seriesHoverInfo = self.getMultiSeriesPlotHoverInfo(plotData, pos);\n\n        seriesHtml = '';\n        timestamp = dashboard.formatDate(seriesHoverInfo.time);\n\n        for (i = 0; i < seriesHoverInfo.length; i++) {\n          hoverInfo = seriesHoverInfo[i];\n\n          if (hoverInfo.hidden) {\n            continue;\n          }\n\n          series = seriesList[i];\n          value = series.formatValue(hoverInfo.value);\n\n          seriesHtml += '<div class=\"graph-tooltip-list-item\"><div class=\"graph-tooltip-series-name\">';\n          seriesHtml += '<i class=\"fa fa-minus\" style=\"color:' + series.color +';\"></i> ' + series.label + ':</div>';\n          seriesHtml += '<div class=\"graph-tooltip-value\">' + value + '</div></div>';\n          plot.highlight(i, hoverInfo.hoverIndex);\n        }\n\n        self.showTooltip(timestamp, seriesHtml, pos);\n      }\n      // single series tooltip\n      else if (item) {\n        series = seriesList[item.seriesIndex];\n        group = '<div class=\"graph-tooltip-list-item\"><div class=\"graph-tooltip-series-name\">';\n        group += '<i class=\"fa fa-minus\" style=\"color:' + item.series.color +';\"></i> ' + series.label + ':</div>';\n\n        if (scope.panel.stack && scope.panel.tooltip.value_type === 'individual') {\n          value = item.datapoint[1] - item.datapoint[2];\n        }\n        else {\n          value = item.datapoint[1];\n        }\n\n        value = series.formatValue(value);\n        timestamp = dashboard.formatDate(item.datapoint[0]);\n        group += '<div class=\"graph-tooltip-value\">' + value + '</div>';\n\n        self.showTooltip(timestamp, group, pos);\n      }\n      // no hit\n      else {\n        $tooltip.detach();\n      }\n    });\n  }\n\n  return GraphTooltip;\n});\n","coverage":[1,null,null,null,null,null,1,14,null,14,null,14,0,0,0,0,0,0,null,null,0,null,null,14,10,10,20,10,null,null,0,null,null,14,0,0,0,null,null,14,5,5,null,null,5,null,5,10,null,10,0,0,null,null,10,10,null,10,4,2,null,2,2,null,null,6,null,null,null,10,null,null,null,0,0,null,10,null,null,null,5,null,null,14,0,0,0,0,0,null,null,null,0,0,null,null,null,14,0,0,0,0,null,0,0,null,null,0,0,null,null,0,0,null,0,null,0,0,null,0,0,null,0,0,null,null,0,0,null,0,0,0,0,null,null,0,null,null,0,0,0,0,null,0,0,null,null,0,null,null,0,0,0,null,0,null,null,null,0,null,null,null,null,1,null,null]},{"name":"public/app/services/timer.js","source":"define([\n  'angular',\n  'lodash'\n],\nfunction (angular, _) {\n  'use strict';\n\n  var module = angular.module('grafana.services');\n\n  module.service('timer', function($timeout) {\n    // This service really just tracks a list of $timeout promises to give us a\n    // method for cancelling them all when we need to\n\n    var timers = [];\n\n    this.register = function(promise) {\n      timers.push(promise);\n      return promise;\n    };\n\n    this.cancel = function(promise) {\n      timers = _.without(timers,promise);\n      $timeout.cancel(promise);\n    };\n\n    this.cancel_all = function() {\n      _.each(timers, function(t) {\n        $timeout.cancel(t);\n      });\n      timers = [];\n    };\n  });\n\n});","coverage":[1,null,null,null,null,null,null,1,null,1,null,null,null,8,null,8,13,13,null,null,8,17,17,null,null,8,12,4,null,12,null,null,null,null]},{"name":"public/app/features/dashboard/shareModalCtrl.js","source":"define([\n  'angular',\n  'lodash',\n  'require',\n  'config',\n],\nfunction (angular, _, require, config) {\n  'use strict';\n\n  var module = angular.module('grafana.controllers');\n\n  module.controller('ShareModalCtrl', function($scope, $rootScope, $location, $timeout, timeSrv, $element, templateSrv) {\n    $scope.options = { forCurrent: true, includeTemplateVars: true, theme: 'current' };\n    $scope.editor = { index: 0 };\n\n    $scope.init = function() {\n      $scope.modeSharePanel = $scope.panel ? true : false;\n\n      $scope.tabs = [{title: 'Link', src: 'shareLink.html'}];\n\n      if ($scope.modeSharePanel) {\n        $scope.modalTitle = 'Share Panel';\n        $scope.tabs.push({title: 'Embed', src: 'shareEmbed.html'});\n      } else {\n        $scope.modalTitle = 'Share Dashboard';\n      }\n\n      if (!$scope.dashboardMeta.isSnapshot) {\n        $scope.tabs.push({title: 'Snapshot sharing', src: 'shareSnapshot.html'});\n      }\n\n      $scope.buildUrl();\n    };\n\n    $scope.buildUrl = function() {\n      var baseUrl = $location.absUrl();\n      var queryStart = baseUrl.indexOf('?');\n\n      if (queryStart !== -1) {\n        baseUrl = baseUrl.substring(0, queryStart);\n      }\n\n      var params = angular.copy($location.search());\n\n      var range = timeSrv.timeRangeForUrl();\n      params.from = range.from;\n      params.to = range.to;\n\n      if ($scope.options.includeTemplateVars) {\n        _.each(templateSrv.variables, function(variable) {\n          params['var-' + variable.name] = variable.current.text;\n        });\n      }\n      else {\n        _.each(templateSrv.variables, function(variable) {\n          delete params['var-' + variable.name];\n        });\n      }\n\n      if (!$scope.options.forCurrent) {\n        delete params.from;\n        delete params.to;\n      }\n\n      if ($scope.options.theme !== 'current') {\n        params.theme = $scope.options.theme;\n      }\n\n      if ($scope.modeSharePanel) {\n        params.panelId = $scope.panel.id;\n        params.fullscreen = true;\n      } else {\n        delete params.panelId;\n        delete params.fullscreen;\n      }\n\n      var paramsArray = [];\n      _.each(params, function(value, key) {\n        if (value === null) { return; }\n        if (value === true) {\n          paramsArray.push(key);\n        } else {\n          key += '=' + encodeURIComponent(value);\n          paramsArray.push(key);\n        }\n      });\n\n      var queryParams = \"?\" + paramsArray.join('&');\n      $scope.shareUrl = baseUrl + queryParams;\n\n      var soloUrl = $scope.shareUrl;\n      soloUrl = soloUrl.replace('/dashboard/db/', '/dashboard/solo/db/');\n      soloUrl = soloUrl.replace('/dashboard/snapshot/', '/dashboard/solo/snapshot/');\n\n      $scope.iframeHtml = '<iframe src=\"' + soloUrl + '\" width=\"450\" height=\"200\" frameborder=\"0\"></iframe>';\n\n      $scope.imageUrl = soloUrl.replace('/dashboard/', '/render/dashboard/');\n      $scope.imageUrl += '&width=1000';\n      $scope.imageUrl += '&height=500';\n    };\n\n  });\n\n  module.directive('clipboardButton',function() {\n    return function(scope, elem) {\n      require(['ZeroClipboard'], function(ZeroClipboard) {\n        ZeroClipboard.config({\n          swfPath: config.appSubUrl + '/public/vendor/ZeroClipboard.swf'\n        });\n        new ZeroClipboard(elem[0]);\n      });\n    };\n  });\n\n});\n","coverage":[1,null,null,null,null,null,null,null,null,1,null,1,5,5,null,5,4,null,4,null,4,2,2,null,2,null,null,4,4,null,null,4,null,null,5,5,5,null,5,0,null,null,5,null,5,5,5,null,5,5,2,null,null,null,0,0,null,null,null,5,0,0,null,null,5,1,null,null,5,2,2,null,3,3,null,null,5,5,17,17,2,null,15,15,null,null,null,5,5,null,5,5,5,null,5,null,5,5,5,null,null,null,null,1,0,0,0,null,null,0,null,null,null,null,null,null]},{"name":"public/app/features/templating/templateValuesSrv.js","source":"define([\n  'angular',\n  'lodash',\n  'kbn',\n],\nfunction (angular, _, kbn) {\n  'use strict';\n\n  var module = angular.module('grafana.services');\n\n  module.service('templateValuesSrv', function($q, $rootScope, datasourceSrv, $location, templateSrv, timeSrv) {\n    var self = this;\n\n    $rootScope.onAppEvent('time-range-changed', function()  {\n      var variable = _.findWhere(self.variables, { type: 'interval' });\n      if (variable) {\n        self.updateAutoInterval(variable);\n      }\n    });\n\n    this.init = function(dashboard) {\n      this.variables = dashboard.templating.list;\n      templateSrv.init(this.variables);\n\n      var queryParams = $location.search();\n      var promises = [];\n\n      for (var i = 0; i < this.variables.length; i++) {\n        var variable = this.variables[i];\n        var urlValue = queryParams['var-' + variable.name];\n        if (urlValue !== void 0) {\n          promises.push(this.setVariableFromUrl(variable, urlValue));\n        }\n        else if (variable.refresh) {\n          promises.push(this.updateOptions(variable));\n        }\n        else if (variable.type === 'interval') {\n          this.updateAutoInterval(variable);\n        }\n      }\n\n      return $q.all(promises);\n    };\n\n    this.setVariableFromUrl = function(variable, urlValue) {\n      if (variable.refresh) {\n        var self = this;\n        //refresh the list of options before setting the value\n        return this.updateOptions(variable).then(function() {\n          var option = _.findWhere(variable.options, { text: urlValue });\n          option = option || { text: urlValue, value: urlValue };\n\n          self.updateAutoInterval(variable);\n          return self.setVariableValue(variable, option);\n        });\n      }\n      var option = _.findWhere(variable.options, { text: urlValue });\n      option = option || { text: urlValue, value: urlValue };\n\n      this.updateAutoInterval(variable);\n      return this.setVariableValue(variable, option);\n    };\n\n    this.updateAutoInterval = function(variable) {\n      if (!variable.auto) { return; }\n\n      // add auto option if missing\n      if (variable.options.length && variable.options[0].text !== 'auto') {\n        variable.options.unshift({ text: 'auto', value: '$__auto_interval' });\n      }\n\n      var interval = kbn.calculateInterval(timeSrv.timeRange(), variable.auto_count);\n      templateSrv.setGrafanaVariable('$__auto_interval', interval);\n    };\n\n    this.setVariableValue = function(variable, option) {\n      variable.current = option;\n      templateSrv.updateTemplateData();\n      return this.updateOptionsInChildVariables(variable);\n    };\n\n    this.variableUpdated = function(variable) {\n      templateSrv.updateTemplateData();\n      return this.updateOptionsInChildVariables(variable);\n    };\n\n    this.updateOptionsInChildVariables = function(updatedVariable) {\n      var promises = _.map(self.variables, function(otherVariable) {\n        if (otherVariable === updatedVariable) {\n          return;\n        }\n        if (templateSrv.containsVariable(otherVariable.query, updatedVariable.name)) {\n          return self.updateOptions(otherVariable);\n        }\n      });\n\n      return $q.all(promises);\n    };\n\n    this._updateNonQueryVariable = function(variable) {\n      // extract options in comma seperated string\n      variable.options = _.map(variable.query.split(/[,]+/), function(text) {\n        return { text: text.trim(), value: text.trim() };\n      });\n\n      if (variable.type === 'interval') {\n        self.updateAutoInterval(variable);\n      }\n    };\n\n    this.updateOptions = function(variable) {\n      if (variable.type !== 'query') {\n        self._updateNonQueryVariable(variable);\n        self.setVariableValue(variable, variable.options[0]);\n        return $q.when([]);\n      }\n\n      return datasourceSrv.get(variable.datasource).then(function(datasource) {\n        return datasource.metricFindQuery(variable.query).then(function (results) {\n          variable.options = self.metricNamesToVariableValues(variable, results);\n\n          if (variable.includeAll) {\n            self.addAllOption(variable);\n          }\n\n          // if parameter has current value\n          // if it exists in options array keep value\n          if (variable.current) {\n            var currentOption = _.findWhere(variable.options, { text: variable.current.text });\n            if (currentOption) {\n              return self.setVariableValue(variable, currentOption);\n            }\n          }\n\n          return self.setVariableValue(variable, variable.options[0]);\n        });\n      });\n    };\n\n    this.metricNamesToVariableValues = function(variable, metricNames) {\n      var regex, options, i, matches;\n      options = {}; // use object hash to remove duplicates\n\n      if (variable.regex) {\n        regex = kbn.stringToJsRegex(templateSrv.replace(variable.regex));\n      }\n\n      for (i = 0; i < metricNames.length; i++) {\n        var value = metricNames[i].text;\n\n        if (regex) {\n          matches = regex.exec(value);\n          if (!matches) { continue; }\n          if (matches.length > 1) {\n            value = matches[1];\n          }\n        }\n\n        options[value] = value;\n      }\n\n      return _.map(_.keys(options), function(key) {\n        return { text: key, value: key };\n      });\n    };\n\n    this.addAllOption = function(variable) {\n      var allValue = '';\n      switch(variable.allFormat) {\n        case 'wildcard':\n          allValue = '*';\n          break;\n        case 'regex wildcard':\n          allValue = '.*';\n          break;\n        case 'regex values':\n          allValue = '(' + _.pluck(variable.options, 'text').join('|') + ')';\n          break;\n        default:\n          allValue = '{';\n          allValue += _.pluck(variable.options, 'text').join(',');\n          allValue += '}';\n      }\n\n      variable.options.unshift({text: 'All', value: allValue});\n    };\n\n  });\n\n});\n","coverage":[1,null,null,null,null,null,null,null,1,null,1,19,null,19,0,0,0,null,null,null,19,0,0,null,0,0,null,0,0,0,0,0,null,0,0,null,0,0,null,null,null,0,null,null,19,0,0,null,0,0,0,null,0,0,null,null,0,0,null,0,0,null,null,19,4,null,null,2,2,null,null,2,2,null,null,19,19,19,19,null,null,19,0,0,null,null,19,19,0,0,null,0,0,null,null,null,19,null,null,19,null,6,23,null,null,6,4,null,null,null,19,19,6,6,6,null,null,13,13,13,null,13,6,null,null,null,null,13,1,1,1,null,null,null,12,null,null,null,null,19,13,13,null,13,4,null,null,13,29,null,29,8,8,5,2,null,null,null,26,null,null,13,25,null,null,null,19,6,6,null,2,2,null,1,1,null,1,1,null,2,2,2,null,null,6,null,null,null,null,null,null]},{"name":"public/app/features/templating/templateSrv.js","source":"define([\n  'angular',\n  'lodash',\n  './editorCtrl',\n  './templateValuesSrv',\n],\nfunction (angular, _) {\n  'use strict';\n\n  var module = angular.module('grafana.services');\n\n  module.service('templateSrv', function() {\n    var self = this;\n\n    this._regex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)\\]\\]/g;\n    this._values = {};\n    this._texts = {};\n    this._grafanaVariables = {};\n\n    this.init = function(variables) {\n      this.variables = variables;\n      this.updateTemplateData();\n    };\n\n    this.updateTemplateData = function() {\n      this._values = {};\n      this._texts = {};\n\n      _.each(this.variables, function(variable) {\n        if (!variable.current || !variable.current.value) { return; }\n\n        this._values[variable.name] = this.renderVariableValue(variable);\n        this._texts[variable.name] = variable.current.text;\n      }, this);\n    };\n\n    this.renderVariableValue = function(variable) {\n      var value = variable.current.value;\n      if (_.isString(value)) {\n        return value;\n      } else {\n        if (variable.multiFormat === 'regex values') {\n          return '(' + value.join('|') + ')';\n        }\n        return '{' + value.join(',') + '}';\n      }\n    };\n\n    this.setGrafanaVariable = function (name, value) {\n      this._grafanaVariables[name] = value;\n    };\n\n    this.variableExists = function(expression) {\n      this._regex.lastIndex = 0;\n      var match = this._regex.exec(expression);\n      return match && (self._values[match[1] || match[2]] !== void 0);\n    };\n\n    this.containsVariable = function(str, variableName) {\n      if (!str) {\n        return false;\n      }\n      return str.indexOf('$' + variableName) !== -1 || str.indexOf('[[' + variableName + ']]') !== -1;\n    };\n\n    this.highlightVariablesAsHtml = function(str) {\n      if (!str || !_.isString(str)) { return str; }\n\n      this._regex.lastIndex = 0;\n      return str.replace(this._regex, function(match, g1, g2) {\n        if (self._values[g1 || g2]) {\n          return '<span class=\"template-variable\">' + match + '</span>';\n        }\n        return match;\n      });\n    };\n\n    this.replace = function(target, scopedVars) {\n      if (!target) { return; }\n\n      var value;\n      this._regex.lastIndex = 0;\n\n      return target.replace(this._regex, function(match, g1, g2) {\n        if (scopedVars) {\n          value = scopedVars[g1 || g2];\n          if (value) { return value.value; }\n        }\n\n        value = self._values[g1 || g2];\n        if (!value) { return match; }\n\n        return self._grafanaVariables[value] || value;\n      });\n    };\n\n    this.replaceWithText = function(target, scopedVars) {\n      if (!target) { return; }\n\n      var value;\n      var text;\n      this._regex.lastIndex = 0;\n\n      return target.replace(this._regex, function(match, g1, g2) {\n        if (scopedVars) {\n          var option = scopedVars[g1 || g2];\n          if (option) { return option.text; }\n        }\n\n        value = self._values[g1 || g2];\n        text = self._texts[g1 || g2];\n        if (!value) { return match; }\n\n        return self._grafanaVariables[value] || text;\n      });\n    };\n\n  });\n\n});\n","coverage":[1,null,null,null,null,null,null,null,null,1,null,1,25,null,25,25,25,25,null,25,11,11,null,null,25,15,15,null,15,17,null,17,17,null,null,null,25,20,20,18,null,2,1,null,1,null,null,null,25,1,null,null,25,1,1,1,null,null,25,2,0,null,2,null,null,25,3,null,3,3,3,2,null,1,null,null,null,25,24,null,24,24,null,24,3,1,1,null,null,2,2,null,2,null,null,null,25,2,null,2,2,2,null,2,3,1,1,null,null,2,2,2,null,2,null,null,null,null,null,null,null]},{"name":"public/app/features/dashboard/dashboardSrv.js","source":"define([\n  'angular',\n  'jquery',\n  'kbn',\n  'lodash',\n  'moment',\n],\nfunction (angular, $, kbn, _, moment) {\n  'use strict';\n\n  var module = angular.module('grafana.services');\n\n  module.factory('dashboardSrv', function()  {\n\n    function DashboardModel (data, meta) {\n      if (!data) {\n        data = {};\n      }\n\n      if (!data.id && data.version) {\n        data.schemaVersion = data.version;\n      }\n\n      this.id = data.id || null;\n      this.title = data.title || 'No Title';\n      this.originalTitle = this.title;\n      this.tags = data.tags || [];\n      this.style = data.style || \"dark\";\n      this.timezone = data.timezone || 'browser';\n      this.editable = data.editable === false ? false : true;\n      this.hideControls = data.hideControls || false;\n      this.sharedCrosshair = data.sharedCrosshair || false;\n      this.rows = data.rows || [];\n      this.nav = data.nav || [];\n      this.time = data.time || { from: 'now-6h', to: 'now' };\n      this.templating = this._ensureListExist(data.templating);\n      this.annotations = this._ensureListExist(data.annotations);\n      this.refresh = data.refresh;\n      this.snapshot = data.snapshot;\n      this.schemaVersion = data.schemaVersion || 0;\n      this.version = data.version || 0;\n\n      if (this.nav.length === 0) {\n        this.nav.push({ type: 'timepicker' });\n      }\n\n      this._updateSchema(data);\n      this._initMeta(meta);\n    }\n\n    var p = DashboardModel.prototype;\n\n    p._initMeta = function(meta) {\n      meta = meta || {};\n\n      meta.canShare = meta.canShare === false ? false : true;\n      meta.canSave = meta.canSave === false ? false : true;\n      meta.canEdit = meta.canEdit === false ? false : true;\n      meta.canStar = meta.canStar === false ? false : true;\n      meta.canDelete = meta.canDelete === false ? false : true;\n\n      if (!this.editable) {\n        meta.canEdit = false;\n        meta.canDelete = false;\n        meta.canSave = false;\n        this.hideControls = true;\n      }\n\n      this.meta = meta;\n    };\n\n    // cleans meta data and other non peristent state\n    p.getSaveModelClone = function() {\n      var copy = angular.copy(this);\n      delete copy.meta;\n      return copy;\n    };\n\n    p._ensureListExist = function (data) {\n      if (!data) { data = {}; }\n      if (!data.list) { data.list = []; }\n      return data;\n    };\n\n    p.getNextPanelId = function() {\n      var i, j, row, panel, max = 0;\n      for (i = 0; i < this.rows.length; i++) {\n        row = this.rows[i];\n        for (j = 0; j < row.panels.length; j++) {\n          panel = row.panels[j];\n          if (panel.id > max) { max = panel.id; }\n        }\n      }\n      return max + 1;\n    };\n\n    p.forEachPanel = function(callback) {\n      var i, j, row;\n      for (i = 0; i < this.rows.length; i++) {\n        row = this.rows[i];\n        for (j = 0; j < row.panels.length; j++) {\n          callback(row.panels[j], j, row, i);\n        }\n      }\n    };\n\n    p.getPanelById = function(id) {\n      for (var i = 0; i < this.rows.length; i++) {\n        var row = this.rows[i];\n        for (var j = 0; j < row.panels.length; j++) {\n          var panel = row.panels[j];\n          if (panel.id === id) {\n            return panel;\n          }\n        }\n      }\n      return null;\n    };\n\n    p.rowSpan = function(row) {\n      return _.reduce(row.panels, function(p,v) {\n        return p + v.span;\n      },0);\n    };\n\n    p.add_panel = function(panel, row) {\n      var rowSpan = this.rowSpan(row);\n      var panelCount = row.panels.length;\n      var space = (12 - rowSpan) - panel.span;\n      panel.id = this.getNextPanelId();\n\n      // try to make room of there is no space left\n      if (space <= 0) {\n        if (panelCount === 1) {\n          row.panels[0].span = 6;\n          panel.span = 6;\n        }\n        else if (panelCount === 2) {\n          row.panels[0].span = 4;\n          row.panels[1].span = 4;\n          panel.span = 4;\n        }\n      }\n\n      row.panels.push(panel);\n    };\n\n    p.hasTemplateVarsOrAnnotations = function() {\n      return this.templating.list.length > 0 || this.annotations.list.length > 0;\n    };\n\n    p.getPanelInfoById = function(panelId) {\n      var result = {};\n      _.each(this.rows, function(row) {\n        _.each(row.panels, function(panel, index) {\n          if (panel.id === panelId) {\n            result.panel = panel;\n            result.row = row;\n            result.index = index;\n            return;\n          }\n        });\n      });\n\n      if (!result.panel) {\n        return null;\n      }\n\n      return result;\n    };\n\n    p.duplicatePanel = function(panel, row) {\n      var rowIndex = _.indexOf(this.rows, row);\n      var newPanel = angular.copy(panel);\n      newPanel.id = this.getNextPanelId();\n\n      var currentRow = this.rows[rowIndex];\n      currentRow.panels.push(newPanel);\n      return newPanel;\n    };\n\n    p.formatDate = function(date, format) {\n      format = format || 'YYYY-MM-DD HH:mm:ss';\n\n      return this.timezone === 'browser' ?\n              moment(date).format(format) :\n              moment.utc(date).format(format);\n    };\n\n    p._updateSchema = function(old) {\n      var i, j, k;\n      var oldVersion = this.schemaVersion;\n      var panelUpgrades = [];\n      this.schemaVersion = 6;\n\n      if (oldVersion === 6) {\n        return;\n      }\n\n      // version 2 schema changes\n      if (oldVersion < 2) {\n\n        if (old.services) {\n          if (old.services.filter) {\n            this.time = old.services.filter.time;\n            this.templating.list = old.services.filter.list || [];\n          }\n          delete this.services;\n        }\n\n        panelUpgrades.push(function(panel) {\n          // rename panel type\n          if (panel.type === 'graphite') {\n            panel.type = 'graph';\n          }\n\n          if (panel.type !== 'graph') {\n            return;\n          }\n\n          if (_.isBoolean(panel.legend)) { panel.legend = { show: panel.legend }; }\n\n          if (panel.grid) {\n            if (panel.grid.min) {\n              panel.grid.leftMin = panel.grid.min;\n              delete panel.grid.min;\n            }\n\n            if (panel.grid.max) {\n              panel.grid.leftMax = panel.grid.max;\n              delete panel.grid.max;\n            }\n          }\n\n          if (panel.y_format) {\n            panel.y_formats[0] = panel.y_format;\n            delete panel.y_format;\n          }\n\n          if (panel.y2_format) {\n            panel.y_formats[1] = panel.y2_format;\n            delete panel.y2_format;\n          }\n        });\n      }\n\n      // schema version 3 changes\n      if (oldVersion < 3) {\n        // ensure panel ids\n        var maxId = this.getNextPanelId();\n        panelUpgrades.push(function(panel) {\n          if (!panel.id) {\n            panel.id = maxId;\n            maxId += 1;\n          }\n        });\n      }\n\n      // schema version 4 changes\n      if (oldVersion < 4) {\n        // move aliasYAxis changes\n        panelUpgrades.push(function(panel) {\n          if (panel.type !== 'graph') { return; }\n          _.each(panel.aliasYAxis, function(value, key) {\n            panel.seriesOverrides = [{ alias: key, yaxis: value }];\n          });\n          delete panel.aliasYAxis;\n        });\n      }\n\n      if (oldVersion < 6) {\n        // move pulldowns to new schema\n        var annotations = _.findWhere(old.pulldowns, { type: 'annotations' });\n\n        if (annotations) {\n          this.annotations = {\n            list: annotations.annotations || [],\n          };\n        }\n\n        // update template variables\n        for (i = 0 ; i < this.templating.list.length; i++) {\n          var variable = this.templating.list[i];\n          if (variable.datasource === void 0) { variable.datasource = null; }\n          if (variable.type === 'filter') { variable.type = 'query'; }\n          if (variable.type === void 0) { variable.type = 'query'; }\n          if (variable.allFormat === void 0) { variable.allFormat = 'glob'; }\n        }\n      }\n\n      if (panelUpgrades.length === 0) {\n        return;\n      }\n\n      for (i = 0; i < this.rows.length; i++) {\n        var row = this.rows[i];\n        for (j = 0; j < row.panels.length; j++) {\n          for (k = 0; k < panelUpgrades.length; k++) {\n            panelUpgrades[k](row.panels[j]);\n          }\n        }\n      }\n    };\n\n    return {\n      create: function(dashboard, meta) {\n        return new DashboardModel(dashboard, meta);\n      }\n    };\n\n  });\n});\n","coverage":[1,null,null,null,null,null,null,null,null,null,1,null,1,null,1,52,0,null,null,52,0,null,null,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,null,52,52,null,null,52,52,null,null,52,null,52,52,null,52,52,52,52,52,null,52,3,3,3,3,null,null,52,null,null,null,52,15,15,15,null,null,52,104,104,104,null,null,52,92,92,112,112,119,119,null,null,92,null,null,52,0,0,0,0,0,null,null,null,null,52,2,2,2,2,2,2,null,null,null,0,null,null,52,2,3,null,null,null,52,1,1,1,1,null,null,1,1,1,1,null,0,0,0,0,null,null,null,1,null,null,52,0,null,null,52,0,0,0,0,0,0,0,0,null,null,null,null,0,0,null,null,0,null,null,52,1,1,1,null,1,1,1,null,null,52,0,null,0,null,null,null,null,52,52,52,52,52,null,52,0,null,null,null,52,null,52,9,9,9,null,9,null,null,52,null,42,9,null,null,42,33,null,null,9,null,9,9,9,9,null,null,9,9,9,null,null,null,9,0,0,null,null,9,0,0,null,null,null,null,null,52,null,52,52,42,16,16,null,null,null,null,null,52,null,52,42,9,9,null,9,null,null,null,52,null,52,null,52,9,null,null,null,null,null,52,39,39,39,39,39,null,null,null,52,0,null,null,52,42,42,42,126,null,null,null,null,null,52,null,52,null,null,null,null,null,null]},{"name":"public/app/features/panel/soloPanelCtrl.js","source":"define([\n  'angular',\n  'jquery',\n],\nfunction (angular, $) {\n  \"use strict\";\n\n  var module = angular.module('grafana.routes');\n\n  module.controller('SoloPanelCtrl', function(\n    $scope,\n    backendSrv,\n    $routeParams,\n    dashboardSrv,\n    timeSrv,\n    $location,\n    templateValuesSrv,\n    contextSrv) {\n\n    var panelId;\n\n    $scope.init = function() {\n      contextSrv.sidemenu = false;\n\n      var params = $location.search();\n      panelId = parseInt(params.panelId);\n\n      var request;\n\n      if ($routeParams.slug) {\n        request = backendSrv.getDashboard($routeParams.slug);\n      } else {\n        request = backendSrv.get('/api/snapshots/' + $routeParams.key);\n      }\n\n      request.then(function(dashboard) {\n        $scope.initPanelScope(dashboard);\n      }).then(null, function(err) {\n        $scope.appEvent('alert-error', ['Load panel error', err.message]);\n      });\n    };\n\n    $scope.initPanelScope = function(dashData) {\n      $scope.dashboard = dashboardSrv.create(dashData.model, dashData.meta);\n\n      $scope.row = {\n        height: ($(window).height() - 10) + 'px',\n      };\n\n      $scope.test = \"Hej\";\n      $scope.$index = 0;\n      $scope.panel = $scope.dashboard.getPanelById(panelId);\n\n      if (!$scope.panel) {\n        $scope.appEvent('alert-error', ['Panel not found', '']);\n        return;\n      }\n\n      $scope.panel.span = 12;\n      $scope.dashboardViewState = { registerPanel: function() { }, state: {}};\n\n      timeSrv.init($scope.dashboard);\n      templateValuesSrv.init($scope.dashboard, $scope.dashboardViewState);\n    };\n\n    if (!$scope.skipAutoInit) {\n      $scope.init();\n    }\n\n  });\n\n});\n","coverage":[1,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,2,null,2,2,null,2,2,null,2,null,2,2,null,0,null,null,2,2,null,0,null,null,null,2,2,null,2,null,null,null,2,2,2,null,2,0,0,null,null,2,2,null,2,2,null,null,2,0,null,null,null,null,null,null]},{"name":"public/app/features/dashboard/viewStateSrv.js","source":"define([\n  'angular',\n  'lodash',\n  'jquery',\n],\nfunction (angular, _, $) {\n  'use strict';\n\n  var module = angular.module('grafana.services');\n\n  module.factory('dashboardViewStateSrv', function($location, $timeout) {\n\n    // represents the transient view state\n    // like fullscreen panel & edit\n    function DashboardViewState($scope) {\n      var self = this;\n      self.state = {};\n      self.panelScopes = [];\n      self.$scope = $scope;\n\n      $scope.exitFullscreen = function() {\n        if (self.state.fullscreen) {\n          self.update({ fullscreen: false });\n        }\n      };\n\n      $scope.onAppEvent('$routeUpdate', function() {\n        var urlState = self.getQueryStringState();\n        if (self.needsSync(urlState)) {\n          self.update(urlState, true);\n        }\n      });\n\n      this.update(this.getQueryStringState(), true);\n      this.expandRowForPanel();\n    }\n\n    DashboardViewState.prototype.expandRowForPanel = function() {\n      if (!this.state.panelId) { return; }\n\n      var panelInfo = this.$scope.dashboard.getPanelInfoById(this.state.panelId);\n      if (panelInfo) {\n        panelInfo.row.collapse = false;\n      }\n    };\n\n    DashboardViewState.prototype.needsSync = function(urlState) {\n      return _.isEqual(this.state, urlState) === false;\n    };\n\n    DashboardViewState.prototype.getQueryStringState = function() {\n      var state = $location.search();\n      state.panelId = parseInt(state.panelId) || null;\n      state.fullscreen = state.fullscreen ? true : null;\n      state.edit =  (state.edit === \"true\" || state.edit === true) || null;\n      state.editview = state.editview || null;\n      return state;\n    };\n\n    DashboardViewState.prototype.serializeToUrl = function() {\n      var urlState = _.clone(this.state);\n      urlState.fullscreen = this.state.fullscreen ? true : null;\n      urlState.edit = this.state.edit ? true : null;\n      return urlState;\n    };\n\n    DashboardViewState.prototype.update = function(state, skipUrlSync) {\n      _.extend(this.state, state);\n      this.fullscreen = this.state.fullscreen;\n\n      if (!this.state.fullscreen) {\n        this.state.panelId = null;\n        this.state.fullscreen = null;\n        this.state.edit = null;\n      }\n\n      if (!skipUrlSync) {\n        $location.search(this.serializeToUrl());\n      }\n\n      this.syncState();\n    };\n\n    DashboardViewState.prototype.syncState = function() {\n      if (this.panelScopes.length === 0) { return; }\n\n      if (this.fullscreen) {\n        if (this.fullscreenPanel) {\n          this.leaveFullscreen(false);\n        }\n        var panelScope = this.getPanelScope(this.state.panelId);\n        this.enterFullscreen(panelScope);\n        return;\n      }\n\n      if (this.fullscreenPanel) {\n        this.leaveFullscreen(true);\n      }\n    };\n\n    DashboardViewState.prototype.getPanelScope = function(id) {\n      return _.find(this.panelScopes, function(panelScope) {\n        return panelScope.panel.id === id;\n      });\n    };\n\n    DashboardViewState.prototype.leaveFullscreen = function(render) {\n      var self = this;\n\n      self.fullscreenPanel.editMode = false;\n      self.fullscreenPanel.fullscreen = false;\n      delete self.fullscreenPanel.height;\n\n      if (!render) { return false;}\n\n      $timeout(function() {\n        if (self.oldTimeRange !== self.fullscreenPanel.range) {\n          self.$scope.broadcastRefresh();\n        }\n        else {\n          self.fullscreenPanel.$broadcast('render');\n        }\n        delete self.fullscreenPanel;\n      });\n    };\n\n    DashboardViewState.prototype.enterFullscreen = function(panelScope) {\n      var docHeight = $(window).height();\n      var editHeight = Math.floor(docHeight * 0.3);\n      var fullscreenHeight = Math.floor(docHeight * 0.7);\n      this.oldTimeRange = panelScope.range;\n\n      panelScope.height = this.state.edit ? editHeight : fullscreenHeight;\n      panelScope.editMode = this.state.edit;\n      this.fullscreenPanel = panelScope;\n\n      $(window).scrollTop(0);\n\n      panelScope.fullscreen = true;\n\n      $timeout(function() {\n        panelScope.$broadcast('render');\n      });\n    };\n\n    DashboardViewState.prototype.registerPanel = function(panelScope) {\n      var self = this;\n      self.panelScopes.push(panelScope);\n\n      if (self.state.panelId === panelScope.panel.id) {\n        self.enterFullscreen(panelScope);\n      }\n\n      panelScope.$on('$destroy', function() {\n        self.panelScopes = _.without(self.panelScopes, panelScope);\n      });\n    };\n\n    return {\n      create: function($scope) {\n        return new DashboardViewState($scope);\n      }\n    };\n\n  });\n});\n","coverage":[1,null,null,null,null,null,null,null,1,null,1,null,null,null,1,2,2,2,2,null,2,0,0,null,null,null,2,0,0,0,null,null,null,2,2,null,null,2,2,null,0,0,0,null,null,null,2,0,null,null,2,2,2,2,2,2,2,null,null,2,3,3,3,3,null,null,2,5,5,null,5,3,3,3,null,null,5,3,null,null,5,null,null,2,5,null,0,0,0,null,0,0,0,null,null,0,0,null,null,null,2,0,0,null,null,null,2,0,null,0,0,0,null,0,null,0,0,0,null,null,0,null,0,null,null,null,2,0,0,0,0,null,0,0,0,null,0,null,0,null,0,0,null,null,null,2,0,0,null,0,0,null,null,0,0,null,null,null,2,null,2,null,null,null,null,null,null]},{"name":"public/app/features/dashboard/unsavedChangesSrv.js","source":"define([\n  'angular',\n  'lodash',\n],\nfunction(angular, _) {\n  'use strict';\n\n  var module = angular.module('grafana.services');\n\n  module.service('unsavedChangesSrv', function($modal, $q, $location, $timeout, contextSrv, $window) {\n\n    function Tracker(dashboard, scope) {\n      var self = this;\n\n      this.original = dashboard.getSaveModelClone();\n      this.current = dashboard;\n      this.originalPath = $location.path();\n      this.scope = scope;\n\n      // register events\n      scope.onAppEvent('dashboard-saved', function() {\n        self.original = self.current.getSaveModelClone();\n        self.originalPath = $location.path();\n      });\n\n      $window.onbeforeunload = function() {\n        if (self.ignoreChanges()) { return; }\n        if (self.hasChanges()) {\n          return \"There are unsaved changes to this dashboard\";\n        }\n      };\n\n      scope.$on(\"$locationChangeStart\", function(event, next) {\n        // check if we should look for changes\n        if (self.originalPath === $location.path()) { return true; }\n        if (self.ignoreChanges()) { return true; }\n\n        if (self.hasChanges()) {\n          event.preventDefault();\n          self.next = next;\n\n          $timeout(function() {\n            self.open_modal();\n          });\n        }\n      });\n    }\n\n    var p = Tracker.prototype;\n\n    // for some dashboards and users\n    // changes should be ignored\n    p.ignoreChanges = function() {\n      if (!this.original) { return false; }\n      if (!contextSrv.isEditor) { return true; }\n      if (!this.current || !this.current.meta) { return true; }\n\n      var meta = this.current.meta;\n      return !meta.canSave || meta.fromScript || meta.fromFile;\n    };\n\n    // remove stuff that should not count in diff\n    p.cleanDashboardFromIgnoredChanges = function(dash) {\n      // ignore time and refresh\n      dash.time = 0;\n      dash.refresh = 0;\n      dash.schemaVersion = 0;\n\n      // filter row and panels properties that should be ignored\n      dash.rows = _.filter(dash.rows, function(row) {\n        if (row.repeatRowId) {\n          return false;\n        }\n\n        row.panels = _.filter(row.panels, function(panel) {\n          if (panel.repeatPanelId) {\n            return false;\n          }\n\n          // remove scopedVars\n          panel.scopedVars = null;\n\n          // ignore panel legend sort\n          if (panel.legend)  {\n            delete panel.legend.sort;\n            delete panel.legend.sortDesc;\n          }\n\n          return true;\n        });\n\n        // ignore collapse state\n        row.collapse = false;\n        return true;\n      });\n\n      // ignore template variable values\n      _.each(dash.templating.list, function(value) {\n        value.current = null;\n        value.options = null;\n      });\n\n    };\n\n    p.hasChanges = function() {\n      var current = this.current.getSaveModelClone();\n      var original = this.original;\n\n      this.cleanDashboardFromIgnoredChanges(current);\n      this.cleanDashboardFromIgnoredChanges(original);\n\n      var currentTimepicker = _.findWhere(current.nav, { type: 'timepicker' });\n      var originalTimepicker = _.findWhere(original.nav, { type: 'timepicker' });\n\n      if (currentTimepicker && originalTimepicker) {\n        currentTimepicker.now = originalTimepicker.now;\n      }\n\n      var currentJson = angular.toJson(current);\n      var originalJson = angular.toJson(original);\n\n      if (currentJson !== originalJson) {\n        return true;\n      }\n\n      return false;\n    };\n\n    p.open_modal = function() {\n      var tracker = this;\n\n      var modalScope = this.scope.$new();\n      modalScope.ignore = function() {\n        tracker.original = null;\n        tracker.goto_next();\n      };\n\n      modalScope.save = function() {\n        tracker.scope.$emit('save-dashboard');\n      };\n\n      var confirmModal = $modal({\n        template: './app/partials/unsaved-changes.html',\n        modalClass: 'confirm-modal',\n        persist: false,\n        show: false,\n        scope: modalScope,\n        keyboard: false\n      });\n\n      $q.when(confirmModal).then(function(modalEl) {\n        modalEl.modal('show');\n      });\n    };\n\n    p.goto_next = function() {\n      var baseLen = $location.absUrl().length - $location.url().length;\n      var nextUrl = this.next.substring(baseLen);\n      $location.url(nextUrl);\n    };\n\n    this.Tracker = Tracker;\n    this.init = function(dashboard, scope) {\n      // wait for different services to patch the dashboard (missing properties)\n      $timeout(function() { new Tracker(dashboard, scope); }, 1200);\n    };\n  });\n});\n","coverage":[1,null,null,null,null,null,null,1,null,1,null,1,7,null,7,7,7,7,null,null,7,0,0,null,null,7,0,0,0,null,null,null,7,null,0,0,null,0,0,0,null,0,0,null,null,null,null,null,7,null,null,null,7,0,0,0,null,0,0,null,null,null,7,null,14,14,14,null,null,14,15,1,null,null,14,15,1,null,null,null,14,null,null,14,14,14,null,null,14,null,null,null,14,14,null,null,null,14,0,0,null,null,null,null,7,7,7,null,7,7,null,7,7,null,7,7,null,null,7,7,null,7,1,null,null,6,null,null,7,0,null,0,0,0,0,null,null,0,0,null,null,0,null,null,null,null,null,null,null,null,0,0,null,null,null,7,0,0,0,null,null,7,7,null,0,null,null,null,null]},{"name":"public/app/features/dashboard/dynamicDashboardSrv.js","source":"define([\n  'angular',\n  'lodash',\n],\nfunction (angular, _) {\n  'use strict';\n\n  var module = angular.module('grafana.services');\n\n  module.service('dynamicDashboardSrv', function()  {\n    var self = this;\n\n    this.init = function(dashboard) {\n      this.iteration = new Date().getTime();\n      this.process(dashboard);\n    };\n\n    this.update = function(dashboard) {\n      this.iteration = this.iteration + 1;\n      this.process(dashboard);\n    };\n\n    this.process = function(dashboard) {\n      if (dashboard.templating.list.length === 0) { return; }\n      this.dashboard = dashboard;\n\n      var i, j, row, panel;\n      for (i = 0; i < this.dashboard.rows.length; i++) {\n        row = this.dashboard.rows[i];\n\n        // handle row repeats\n        if (row.repeat) {\n          this.repeatRow(row);\n        }\n        // clean up old left overs\n        else if (row.repeatRowId && row.repeatIteration !== this.iteration) {\n          this.dashboard.rows.splice(i, 1);\n          i = i - 1;\n        }\n\n        // repeat panels\n        for (j = 0; j < row.panels.length; j++) {\n          panel = row.panels[j];\n          if (panel.repeat) {\n            this.repeatPanel(panel, row);\n          }\n          // clean up old left overs\n          else if (panel.repeatPanelId && panel.repeatIteration !== this.iteration) {\n            row.panels = _.without(row.panels, panel);\n            j = j - 1;\n          }\n        }\n      }\n    };\n\n    // returns a new row clone or reuses a clone from previous iteration\n    this.getRowClone = function(sourceRow, index) {\n      if (index === 0) {\n        return sourceRow;\n      }\n\n      var i, panel, row, copy;\n      var sourceRowId = _.indexOf(this.dashboard.rows, sourceRow) + 1;\n\n      // look for row to reuse\n      for (i = 0; i < this.dashboard.rows.length; i++) {\n        row = this.dashboard.rows[i];\n        if (row.repeatRowId === sourceRowId && row.repeatIteration !== this.iteration) {\n          copy = row;\n          break;\n        }\n      }\n\n      if (!copy) {\n        copy = angular.copy(sourceRow);\n        this.dashboard.rows.push(copy);\n\n        // set new panel ids\n        for (i = 0; i < copy.panels.length; i++) {\n          panel = copy.panels[i];\n          panel.id = this.dashboard.getNextPanelId();\n        }\n      }\n\n      copy.repeat = null;\n      copy.repeatRowId = sourceRowId;\n      copy.repeatIteration = this.iteration;\n      return copy;\n    };\n\n    // returns a new panel clone or reuses a clone from previous iteration\n    this.repeatRow = function(row) {\n      var variables = this.dashboard.templating.list;\n      var variable = _.findWhere(variables, {name: row.repeat.replace('$', '')});\n      if (!variable) {\n        return;\n      }\n\n      var selected, copy, i, panel;\n      if (variable.current.text === 'All') {\n        selected = variable.options.slice(1, variable.options.length);\n      } else {\n        selected = _.filter(variable.options, {selected: true});\n      }\n\n      _.each(selected, function(option, index) {\n        copy = self.getRowClone(row, index);\n\n        for (i = 0; i < copy.panels.length; i++) {\n          panel = copy.panels[i];\n          panel.scopedVars = {};\n          panel.scopedVars[variable.name] = option;\n        }\n      });\n    };\n\n    this.getPanelClone = function(sourcePanel, row, index) {\n      // if first clone return source\n      if (index === 0) {\n        return sourcePanel;\n      }\n\n      var i, tmpId, panel, clone;\n\n      // first try finding an existing clone to use\n      for (i = 0; i < row.panels.length; i++) {\n        panel = row.panels[i];\n        if (panel.repeatIteration !== this.iteration && panel.repeatPanelId === sourcePanel.id) {\n          clone = panel;\n          break;\n        }\n      }\n\n      if (!clone) {\n        clone = { id: this.dashboard.getNextPanelId() };\n        row.panels.push(clone);\n      }\n\n      // save id\n      tmpId = clone.id;\n      // copy properties from source\n      angular.copy(sourcePanel, clone);\n      // restore id\n      clone.id = tmpId;\n      clone.repeatIteration = this.iteration;\n      clone.repeatPanelId = sourcePanel.id;\n      clone.repeat = null;\n      return clone;\n    };\n\n    this.repeatPanel = function(panel, row) {\n      var variables = this.dashboard.templating.list;\n      var variable = _.findWhere(variables, {name: panel.repeat});\n      if (!variable) { return; }\n\n      var selected;\n      if (variable.current.text === 'All') {\n        selected = variable.options.slice(1, variable.options.length);\n      } else {\n        selected = _.filter(variable.options, {selected: true});\n      }\n\n      _.each(selected, function(option, index) {\n        var copy = self.getPanelClone(panel, row, index);\n        copy.scopedVars = copy.scopedVars || {};\n        copy.scopedVars[variable.name] = option;\n      });\n    };\n\n  });\n});\n","coverage":[1,null,null,null,null,null,null,1,null,1,23,null,23,23,23,null,null,23,7,7,null,null,23,30,30,null,30,30,49,null,null,49,19,null,null,30,1,1,null,null,null,49,74,74,25,null,null,49,1,1,null,null,null,null,null,null,23,37,19,null,null,18,18,null,null,18,20,20,2,2,null,null,null,18,16,16,null,null,16,16,16,null,null,null,18,18,18,18,null,null,null,23,19,19,19,0,null,null,19,19,0,null,19,null,null,19,37,null,37,37,37,37,null,null,null,null,23,null,49,25,null,null,24,null,null,24,27,27,3,3,null,null,null,24,21,21,null,null,null,24,null,24,null,24,24,24,24,24,null,null,23,25,25,25,null,25,25,0,null,25,null,null,25,49,49,49,null,null,null,null,null,null]},{"name":"public/app/plugins/datasource/graphite/funcEditor.js","source":"define([\n  'angular',\n  'lodash',\n  'jquery',\n],\nfunction (angular, _, $) {\n  'use strict';\n\n  angular\n    .module('grafana.directives')\n    .directive('graphiteFuncEditor', function($compile, templateSrv) {\n\n      var funcSpanTemplate = '<a ng-click=\"\">{{func.def.name}}</a><span>(</span>';\n      var paramTemplate = '<input type=\"text\" style=\"display:none\"' +\n                          ' class=\"input-mini tight-form-func-param\"></input>';\n\n      var funcControlsTemplate =\n         '<div class=\"tight-form-func-controls\">' +\n           '<span class=\"pointer fa fa-arrow-left\"></span>' +\n           '<span class=\"pointer fa fa-question-circle\"></span>' +\n           '<span class=\"pointer fa fa-remove\" ></span>' +\n           '<span class=\"pointer fa fa-arrow-right\"></span>' +\n         '</div>';\n\n      return {\n        restrict: 'A',\n        link: function postLink($scope, elem) {\n          var $funcLink = $(funcSpanTemplate);\n          var $funcControls = $(funcControlsTemplate);\n          var func = $scope.func;\n          var funcDef = func.def;\n          var scheduledRelink = false;\n          var paramCountAtLink = 0;\n\n          function clickFuncParam(paramIndex) {\n            /*jshint validthis:true */\n\n            var $link = $(this);\n            var $input = $link.next();\n\n            $input.val(func.params[paramIndex]);\n            $input.css('width', ($link.width() + 16) + 'px');\n\n            $link.hide();\n            $input.show();\n            $input.focus();\n            $input.select();\n\n            var typeahead = $input.data('typeahead');\n            if (typeahead) {\n              $input.val('');\n              typeahead.lookup();\n            }\n          }\n\n          function scheduledRelinkIfNeeded() {\n            if (paramCountAtLink === func.params.length) {\n              return;\n            }\n\n            if (!scheduledRelink) {\n              scheduledRelink = true;\n              setTimeout(function() {\n                relink();\n                scheduledRelink = false;\n              }, 200);\n            }\n          }\n\n          function inputBlur(paramIndex) {\n            /*jshint validthis:true */\n            var $input = $(this);\n            var $link = $input.prev();\n            var newValue = $input.val();\n\n            if (newValue !== '' || func.def.params[paramIndex].optional) {\n              $link.html(templateSrv.highlightVariablesAsHtml(newValue));\n\n              func.updateParam($input.val(), paramIndex);\n              scheduledRelinkIfNeeded();\n\n              $scope.$apply($scope.targetChanged);\n            }\n\n            $input.hide();\n            $link.show();\n          }\n\n          function inputKeyPress(paramIndex, e) {\n            /*jshint validthis:true */\n            if(e.which === 13) {\n              inputBlur.call(this, paramIndex);\n            }\n          }\n\n          function inputKeyDown() {\n            /*jshint validthis:true */\n            this.style.width = (3 + this.value.length) * 8 + 'px';\n          }\n\n          function addTypeahead($input, paramIndex) {\n            $input.attr('data-provide', 'typeahead');\n\n            var options = funcDef.params[paramIndex].options;\n            if (funcDef.params[paramIndex].type === 'int') {\n              options = _.map(options, function(val) { return val.toString(); });\n            }\n\n            $input.typeahead({\n              source: options,\n              minLength: 0,\n              items: 20,\n              updater: function (value) {\n                setTimeout(function() {\n                  inputBlur.call($input[0], paramIndex);\n                }, 0);\n                return value;\n              }\n            });\n\n            var typeahead = $input.data('typeahead');\n            typeahead.lookup = function () {\n              this.query = this.$element.val() || '';\n              return this.process(this.source);\n            };\n          }\n\n          function toggleFuncControls() {\n            var targetDiv = elem.closest('.tight-form');\n\n            if (elem.hasClass('show-function-controls')) {\n              elem.removeClass('show-function-controls');\n              targetDiv.removeClass('has-open-function');\n              $funcControls.hide();\n              return;\n            }\n\n            elem.addClass('show-function-controls');\n            targetDiv.addClass('has-open-function');\n\n            $funcControls.show();\n          }\n\n          function addElementsAndCompile() {\n            $funcControls.appendTo(elem);\n            $funcLink.appendTo(elem);\n\n            _.each(funcDef.params, function(param, index) {\n              if (param.optional && func.params.length <= index) {\n                return;\n              }\n\n              if (index > 0) {\n                $('<span>, </span>').appendTo(elem);\n              }\n\n              var paramValue = templateSrv.highlightVariablesAsHtml(func.params[index]);\n              var $paramLink = $('<a ng-click=\"\" class=\"graphite-func-param-link\">' + paramValue + '</a>');\n              var $input = $(paramTemplate);\n\n              paramCountAtLink++;\n\n              $paramLink.appendTo(elem);\n              $input.appendTo(elem);\n\n              $input.blur(_.partial(inputBlur, index));\n              $input.keyup(inputKeyDown);\n              $input.keypress(_.partial(inputKeyPress, index));\n              $paramLink.click(_.partial(clickFuncParam, index));\n\n              if (funcDef.params[index].options) {\n                addTypeahead($input, index);\n              }\n\n            });\n\n            $('<span>)</span>').appendTo(elem);\n\n            $compile(elem.contents())($scope);\n          }\n\n          function ifJustAddedFocusFistParam() {\n            if ($scope.func.added) {\n              $scope.func.added = false;\n              setTimeout(function() {\n                elem.find('.graphite-func-param-link').first().click();\n              }, 10);\n            }\n          }\n\n          function registerFuncControlsToggle() {\n            $funcLink.click(toggleFuncControls);\n          }\n\n          function registerFuncControlsActions() {\n            $funcControls.click(function(e) {\n              var $target = $(e.target);\n              if ($target.hasClass('fa-remove')) {\n                toggleFuncControls();\n                $scope.$apply(function() {\n                  $scope.removeFunction($scope.func);\n                });\n                return;\n              }\n\n              if ($target.hasClass('fa-arrow-left')) {\n                $scope.$apply(function() {\n                  _.move($scope.functions, $scope.$index, $scope.$index - 1);\n                  $scope.targetChanged();\n                });\n                return;\n              }\n\n              if ($target.hasClass('fa-arrow-right')) {\n                $scope.$apply(function() {\n                  _.move($scope.functions, $scope.$index, $scope.$index + 1);\n                  $scope.targetChanged();\n                });\n                return;\n              }\n\n              if ($target.hasClass('fa-question-circle')) {\n                window.open(\"http://graphite.readthedocs.org/en/latest/functions.html#graphite.render.functions.\" + funcDef.name,'_blank');\n                return;\n              }\n            });\n          }\n\n          function relink() {\n            elem.children().remove();\n\n            addElementsAndCompile();\n            ifJustAddedFocusFistParam();\n            registerFuncControlsToggle();\n            registerFuncControlsActions();\n          }\n\n          relink();\n        }\n      };\n\n    });\n\n});\n","coverage":[1,null,null,null,null,null,null,null,1,null,null,null,0,0,null,null,0,null,null,null,null,null,null,null,0,null,null,0,0,0,0,0,0,null,1,null,null,0,0,null,0,0,null,0,0,0,0,null,0,0,0,0,null,null,null,1,0,0,null,null,0,0,0,0,0,null,null,null,null,1,null,0,0,0,null,0,0,null,0,0,null,0,null,null,0,0,null,null,1,null,0,0,null,null,null,1,null,0,null,null,1,0,null,0,0,0,null,null,0,null,null,null,null,0,0,null,0,null,null,null,0,0,0,0,null,null,null,1,0,null,0,0,0,0,0,null,null,0,0,null,0,null,null,1,0,0,null,0,0,0,null,null,0,0,null,null,0,0,0,null,0,null,0,0,null,0,0,0,0,null,0,0,null,null,null,null,0,null,0,null,null,1,0,0,0,0,null,null,null,null,1,0,null,null,1,0,0,0,0,0,0,null,0,null,null,0,0,0,0,null,0,null,null,0,0,0,0,null,0,null,null,0,0,0,null,null,null,null,1,0,null,0,0,0,0,null,null,0,null,null,null,null,null,null,null]},{"name":"public/app/plugins/datasource/influxdb_08/queryCtrl.js","source":"define([\n  'angular',\n  'lodash'\n],\nfunction (angular, _) {\n  'use strict';\n\n  var module = angular.module('grafana.controllers');\n\n  var seriesList = null;\n\n  module.controller('InfluxQueryCtrl_08', function($scope, $timeout) {\n\n    $scope.init = function() {\n      var target = $scope.target;\n\n      target.function = target.function || 'mean';\n      target.column = target.column || 'value';\n\n      // backward compatible correction of schema\n      if (target.condition_value) {\n        target.condition = target.condition_key + ' ' + target.condition_op + ' ' + target.condition_value;\n        delete target.condition_key;\n        delete target.condition_op;\n        delete target.condition_value;\n      }\n\n      if (target.groupby_field_add === false) {\n        target.groupby_field = '';\n        delete target.groupby_field_add;\n      }\n\n      $scope.rawQuery = false;\n\n      $scope.functions = [\n        'count', 'mean', 'sum', 'min',\n        'max', 'mode', 'distinct', 'median',\n        'derivative', 'stddev', 'first', 'last',\n        'difference'\n      ];\n\n      $scope.operators = ['=', '=~', '>', '<', '!~', '<>'];\n      $scope.oldSeries = target.series;\n      $scope.$on('typeahead-updated', function() {\n        $timeout($scope.get_data);\n      });\n    };\n\n    $scope.showQuery = function () {\n      $scope.target.rawQuery = true;\n    };\n\n    $scope.hideQuery = function () {\n      $scope.target.rawQuery = false;\n    };\n\n    // Cannot use typeahead and ng-change on blur at the same time\n    $scope.seriesBlur = function() {\n      if ($scope.oldSeries !== $scope.target.series) {\n        $scope.oldSeries = $scope.target.series;\n        $scope.columnList = null;\n        $scope.get_data();\n      }\n    };\n\n    $scope.changeFunction = function(func) {\n      $scope.target.function = func;\n      $scope.get_data();\n    };\n\n    // called outside of digest\n    $scope.listColumns = function(query, callback) {\n      if (!$scope.columnList) {\n        $scope.$apply(function() {\n          $scope.datasource.listColumns($scope.target.series).then(function(columns) {\n            $scope.columnList = columns;\n            callback(columns);\n          });\n        });\n      }\n      else {\n        return $scope.columnList;\n      }\n    };\n\n    $scope.listSeries = function(query, callback) {\n      if (query !== '') {\n        seriesList = [];\n        $scope.datasource.listSeries(query).then(function(series) {\n          seriesList = series;\n          callback(seriesList);\n        });\n      }\n      else {\n        return seriesList;\n      }\n    };\n\n    $scope.moveMetricQuery = function(fromIndex, toIndex) {\n      _.move($scope.panel.targets, fromIndex, toIndex);\n    };\n\n    $scope.duplicate = function() {\n      var clone = angular.copy($scope.target);\n      $scope.panel.targets.push(clone);\n    };\n\n  });\n\n});\n","coverage":[1,null,null,null,null,null,null,1,null,1,null,1,null,0,0,null,0,0,null,null,0,0,0,0,0,null,null,0,0,0,null,null,0,null,0,null,null,null,null,null,null,0,0,0,0,null,null,null,0,0,null,null,0,0,null,null,null,0,0,0,0,0,null,null,null,0,0,0,null,null,null,0,0,0,0,0,0,null,null,null,null,0,null,null,null,0,0,0,0,0,0,null,null,null,0,null,null,null,0,0,null,null,0,0,0,null,null,null,null,null,null]},{"name":"public/app/plugins/datasource/graphite/addGraphiteFunc.js","source":"define([\n  'angular',\n  'app',\n  'lodash',\n  'jquery',\n  './gfunc',\n],\nfunction (angular, app, _, $, gfunc) {\n  'use strict';\n\n  angular\n    .module('grafana.directives')\n    .directive('graphiteAddFunc', function($compile) {\n      var inputTemplate = '<input type=\"text\"'+\n                            ' class=\"tight-form-input input-medium tight-form-input\"' +\n                            ' spellcheck=\"false\" style=\"display:none\"></input>';\n\n      var buttonTemplate = '<a  class=\"tight-form-item tight-form-func dropdown-toggle\"' +\n                              ' tabindex=\"1\" gf-dropdown=\"functionMenu\" data-toggle=\"dropdown\"' +\n                              ' data-placement=\"top\"><i class=\"fa fa-plus\"></i></a>';\n\n      return {\n        link: function($scope, elem) {\n          var categories = gfunc.getCategories();\n          var allFunctions = getAllFunctionNames(categories);\n\n          $scope.functionMenu = createFunctionDropDownMenu(categories);\n\n          var $input = $(inputTemplate);\n          var $button = $(buttonTemplate);\n          $input.appendTo(elem);\n          $button.appendTo(elem);\n\n          $input.attr('data-provide', 'typeahead');\n          $input.typeahead({\n            source: allFunctions,\n            minLength: 1,\n            items: 10,\n            updater: function (value) {\n              var funcDef = gfunc.getFuncDef(value);\n              if (!funcDef) {\n                // try find close match\n                value = value.toLowerCase();\n                funcDef = _.find(allFunctions, function(funcName) {\n                  return funcName.toLowerCase().indexOf(value) === 0;\n                });\n\n                if (!funcDef) { return; }\n              }\n\n              $scope.$apply(function() {\n                $scope.addFunction(funcDef);\n              });\n\n              $input.trigger('blur');\n              return '';\n            }\n          });\n\n          $button.click(function() {\n            $button.hide();\n            $input.show();\n            $input.focus();\n          });\n\n          $input.keyup(function() {\n            elem.toggleClass('open', $input.val() === '');\n          });\n\n          $input.blur(function() {\n            // clicking the function dropdown menu wont\n            // work if you remove class at once\n            setTimeout(function() {\n              $input.val('');\n              $input.hide();\n              $button.show();\n              elem.removeClass('open');\n            }, 200);\n          });\n\n          $compile(elem.contents())($scope);\n        }\n      };\n    });\n\n  function getAllFunctionNames(categories) {\n    return _.reduce(categories, function(list, category) {\n      _.each(category, function(func) {\n        list.push(func.name);\n      });\n      return list;\n    }, []);\n  }\n\n  function createFunctionDropDownMenu(categories) {\n    return _.map(categories, function(list, category) {\n      return {\n        text: category,\n        submenu: _.map(list, function(value) {\n          return {\n            text: value.name,\n            click: \"addFunction('\" + value.name + \"')\",\n          };\n        })\n      };\n    });\n  }\n});\n","coverage":[1,null,null,null,null,null,null,null,null,null,1,null,null,0,null,null,null,0,null,null,null,0,null,0,0,null,0,null,0,0,0,0,null,0,0,null,null,null,null,0,0,null,0,0,0,null,null,0,null,null,0,0,null,null,0,0,null,null,null,0,0,0,0,null,null,0,0,null,null,0,null,null,0,0,0,0,0,null,null,null,0,null,null,null,null,1,0,0,0,null,0,null,null,null,1,0,0,null,null,0,null,null,null,null,null,null,null,null,null]},{"name":"public/app/plugins/datasource/influxdb_08/funcEditor.js","source":"define([\n  'angular',\n  'lodash',\n  'jquery',\n],\nfunction (angular, _, $) {\n  'use strict';\n\n  angular\n    .module('grafana.directives')\n    .directive('influxdbFuncEditor08', function($compile) {\n\n      var funcSpanTemplate = '<a gf-dropdown=\"functionMenu\" class=\"dropdown-toggle\" ' +\n                             'data-toggle=\"dropdown\">{{target.function}}</a><span>(</span>';\n\n      var paramTemplate = '<input type=\"text\" style=\"display:none\"' +\n                          ' class=\"input-mini tight-form-func-param\"></input>';\n\n      return {\n        restrict: 'A',\n        link: function postLink($scope, elem) {\n          var $funcLink = $(funcSpanTemplate);\n\n          $scope.functionMenu = _.map($scope.functions, function(func) {\n            return {\n              text: func,\n              click: \"changeFunction('\" + func + \"');\"\n            };\n          });\n\n          function clickFuncParam() {\n            /*jshint validthis:true */\n\n            var $link = $(this);\n            var $input = $link.next();\n\n            $input.val($scope.target.column);\n            $input.css('width', ($link.width() + 16) + 'px');\n\n            $link.hide();\n            $input.show();\n            $input.focus();\n            $input.select();\n\n            var typeahead = $input.data('typeahead');\n            if (typeahead) {\n              $input.val('');\n              typeahead.lookup();\n            }\n          }\n\n          function inputBlur() {\n            /*jshint validthis:true */\n\n            var $input = $(this);\n            var $link = $input.prev();\n\n            if ($input.val() !== '') {\n              $link.text($input.val());\n\n              $scope.target.column = $input.val();\n              $scope.$apply($scope.get_data);\n            }\n\n            $input.hide();\n            $link.show();\n          }\n\n          function inputKeyPress(e) {\n            /*jshint validthis:true */\n\n            if(e.which === 13) {\n              inputBlur.call(this);\n            }\n          }\n\n          function inputKeyDown() {\n            /*jshint validthis:true */\n            this.style.width = (3 + this.value.length) * 8 + 'px';\n          }\n\n          function addTypeahead($input) {\n            $input.attr('data-provide', 'typeahead');\n\n            $input.typeahead({\n              source: function () {\n                return $scope.listColumns.apply(null, arguments);\n              },\n              minLength: 0,\n              items: 20,\n              updater: function (value) {\n                setTimeout(function() {\n                  inputBlur.call($input[0]);\n                }, 0);\n                return value;\n              }\n            });\n\n            var typeahead = $input.data('typeahead');\n            typeahead.lookup = function () {\n              var items;\n              this.query = this.$element.val() || '';\n              items = this.source(this.query, $.proxy(this.process, this));\n              return items ? this.process(items) : items;\n            };\n          }\n\n          function addElementsAndCompile() {\n            $funcLink.appendTo(elem);\n\n            var $paramLink = $('<a ng-click=\"\" class=\"graphite-func-param-link\">' + $scope.target.column + '</a>');\n            var $input = $(paramTemplate);\n\n            $paramLink.appendTo(elem);\n            $input.appendTo(elem);\n\n            $input.blur(inputBlur);\n            $input.keyup(inputKeyDown);\n            $input.keypress(inputKeyPress);\n            $paramLink.click(clickFuncParam);\n\n            addTypeahead($input);\n\n            $('<span>)</span>').appendTo(elem);\n\n            $compile(elem.contents())($scope);\n          }\n\n          addElementsAndCompile();\n\n        }\n      };\n\n    });\n\n});\n","coverage":[1,null,null,null,null,null,null,null,1,null,null,null,0,null,null,0,null,null,0,null,null,0,null,0,0,null,null,null,null,null,1,null,null,0,0,null,0,0,null,0,0,0,0,null,0,0,0,0,null,null,null,1,null,null,0,0,null,0,0,null,0,0,null,null,0,0,null,null,1,null,null,0,0,null,null,null,1,null,0,null,null,1,0,null,0,null,0,null,null,null,null,0,0,null,0,null,null,null,0,0,0,0,0,0,null,null,null,1,0,null,0,0,null,0,0,null,0,0,0,0,null,0,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null]},{"name":"public/app/components/panelmeta.js","source":"define([\n],\nfunction () {\n  \"use strict\";\n\n  function PanelMeta(options) {\n    this.description = options.description;\n    this.fullscreen = options.fullscreen;\n    this.editIcon = options.editIcon;\n    this.panelName = options.panelName;\n    this.menu = [];\n    this.editorTabs = [];\n    this.extendedMenu = [];\n\n    if (options.fullscreen) {\n      this.addMenuItem('view', 'icon-eye-open', 'toggleFullscreen(false); dismiss();');\n    }\n\n    this.addMenuItem('edit', 'icon-cog', 'editPanel(); dismiss();');\n    this.addMenuItem('duplicate', 'icon-copy', 'duplicatePanel()');\n    this.addMenuItem('share', 'icon-share', 'sharePanel(); dismiss();');\n\n    this.addEditorTab('General', 'app/partials/panelgeneral.html');\n\n    if (options.metricsEditor) {\n      this.addEditorTab('Metrics', 'app/partials/metrics.html');\n    }\n\n    this.addExtendedMenuItem('Panel JSON', '', 'editPanelJson(); dismiss();');\n  }\n\n  PanelMeta.prototype.addMenuItem = function(text, icon, click) {\n    this.menu.push({text: text, icon: icon, click: click});\n  };\n\n  PanelMeta.prototype.addExtendedMenuItem = function(text, icon, click) {\n    this.extendedMenu.push({text: text, icon: icon, click: click});\n  };\n\n  PanelMeta.prototype.addEditorTab = function(title, src) {\n    this.editorTabs.push({title: title, src: src});\n  };\n\n  return PanelMeta;\n\n});\n","coverage":[1,null,null,null,null,1,1,1,1,1,1,1,1,null,1,1,null,null,1,1,1,null,1,null,1,1,null,null,1,null,null,1,4,null,null,1,3,null,null,1,5,null,null,1,null,null,null]},{"name":"public/app/panels/graph/legend.js","source":"define([\n  'angular',\n  'app',\n  'lodash',\n  'kbn',\n  'jquery',\n  'jquery.flot',\n  'jquery.flot.time',\n],\nfunction (angular, app, _, kbn, $) {\n  'use strict';\n\n  var module = angular.module('grafana.panels.graph');\n\n  module.directive('graphLegend', function(popoverSrv) {\n\n    return {\n      link: function(scope, elem) {\n        var $container = $('<section class=\"graph-legend\"></section>');\n        var firstRender = true;\n        var panel = scope.panel;\n        var data;\n        var seriesList;\n        var i;\n\n        scope.$on('render', function() {\n          data = scope.seriesList;\n          if (data) {\n            render();\n          }\n        });\n\n        function getSeriesIndexForElement(el) {\n          return el.parents('[data-series-index]').data('series-index');\n        }\n\n        function openColorSelector(e) {\n          var el = $(e.currentTarget);\n          var index = getSeriesIndexForElement(el);\n          var seriesInfo = seriesList[index];\n          var popoverScope = scope.$new();\n          popoverScope.series = seriesInfo;\n          popoverSrv.show({\n            element: $(':first-child', el),\n            templateUrl:  'app/panels/graph/legend.popover.html',\n            scope: popoverScope\n          });\n        }\n\n        function toggleSeries(e) {\n          var el = $(e.currentTarget);\n          var index = getSeriesIndexForElement(el);\n          var seriesInfo = seriesList[index];\n          scope.toggleSeries(seriesInfo, e);\n        }\n\n        function sortLegend(e) {\n          var el = $(e.currentTarget);\n          var stat = el.data('stat');\n\n          if (stat !== panel.legend.sort) { panel.legend.sortDesc = null; }\n\n          // if already sort ascending, disable sorting\n          if (panel.legend.sortDesc === false) {\n            panel.legend.sort = null;\n            panel.legend.sortDesc = null;\n            render();\n            return;\n          }\n\n          panel.legend.sortDesc = !panel.legend.sortDesc;\n          panel.legend.sort = stat;\n          render();\n        }\n\n        function getTableHeaderHtml(statName) {\n          if (!panel.legend[statName]) { return \"\"; }\n          var html = '<th class=\"pointer\" data-stat=\"' + statName + '\">' + statName;\n\n          if (panel.legend.sort === statName) {\n            var cssClass = panel.legend.sortDesc ? 'fa fa-caret-down' : 'fa fa-caret-up' ;\n            html += ' <span class=\"' + cssClass + '\"></span>';\n          }\n\n          return html + '</th>';\n        }\n\n        function render() {\n          if (firstRender) {\n            elem.append($container);\n            $container.on('click', '.graph-legend-icon', openColorSelector);\n            $container.on('click', '.graph-legend-alias', toggleSeries);\n            $container.on('click', 'th', sortLegend);\n            firstRender = false;\n          }\n\n          seriesList = data;\n\n          $container.empty();\n\n          $container.toggleClass('graph-legend-table', panel.legend.alignAsTable === true);\n\n          if (panel.legend.alignAsTable) {\n            var header = '<tr>';\n            header += '<th colspan=\"2\" style=\"text-align:left\"></th>';\n            if (panel.legend.values) {\n              header += getTableHeaderHtml('min');\n              header += getTableHeaderHtml('max');\n              header += getTableHeaderHtml('avg');\n              header += getTableHeaderHtml('current');\n              header += getTableHeaderHtml('total');\n            }\n            header += '</tr>';\n            $container.append($(header));\n          }\n\n          if (panel.legend.sort) {\n            seriesList = _.sortBy(seriesList, function(series) {\n              return series.stats[panel.legend.sort];\n            });\n            if (panel.legend.sortDesc) {\n              seriesList = seriesList.reverse();\n            }\n          }\n\n          for (i = 0; i < seriesList.length; i++) {\n            var series = seriesList[i];\n\n            // ignore empty series\n            if (panel.legend.hideEmpty && series.allIsNull) {\n              continue;\n            }\n\n            var html = '<div class=\"graph-legend-series';\n            if (series.yaxis === 2) { html += ' pull-right'; }\n            if (scope.hiddenSeries[series.alias]) { html += ' graph-legend-series-hidden'; }\n            html += '\" data-series-index=\"' + i + '\">';\n            html += '<div class=\"graph-legend-icon\">';\n            html += '<i class=\"fa fa-minus pointer\" style=\"color:' + series.color + '\"></i>';\n            html += '</div>';\n\n            html += '<div class=\"graph-legend-alias\">';\n            html += '<a>' + series.label + '</a>';\n            html += '</div>';\n\n            if (panel.legend.values) {\n              var avg = series.formatValue(series.stats.avg);\n              var current = series.formatValue(series.stats.current);\n              var min = series.formatValue(series.stats.min);\n              var max = series.formatValue(series.stats.max);\n              var total = series.formatValue(series.stats.total);\n\n              if (panel.legend.min) { html += '<div class=\"graph-legend-value min\">' + min + '</div>'; }\n              if (panel.legend.max) { html += '<div class=\"graph-legend-value max\">' + max + '</div>'; }\n              if (panel.legend.avg) { html += '<div class=\"graph-legend-value avg\">' + avg + '</div>'; }\n              if (panel.legend.current) { html += '<div class=\"graph-legend-value current\">' + current + '</div>'; }\n              if (panel.legend.total) { html += '<div class=\"graph-legend-value total\">' + total + '</div>'; }\n            }\n\n            html += '</div>';\n            $container.append($(html));\n          }\n        }\n      }\n    };\n  });\n\n});\n","coverage":[1,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,0,null,0,0,0,0,0,0,null,0,0,0,0,null,null,null,1,0,null,null,1,0,0,0,0,0,0,null,null,null,null,null,null,1,0,0,0,0,null,null,1,0,0,null,0,null,null,0,0,0,0,0,null,null,0,0,0,null,null,1,0,0,null,0,0,0,null,null,0,null,null,1,0,0,0,0,0,0,null,null,0,null,0,null,0,null,0,0,0,0,0,0,0,0,0,null,0,0,null,null,0,0,0,null,0,0,null,null,null,0,0,null,null,0,0,null,null,0,0,0,0,0,0,0,null,0,0,0,null,0,0,0,0,0,0,null,0,0,0,0,0,null,null,0,0,null,null,null,null,null,null,null,null]},{"name":"public/app/features/templating/editorCtrl.js","source":"define([\n  'angular',\n  'lodash',\n],\nfunction (angular, _) {\n  'use strict';\n\n  var module = angular.module('grafana.controllers');\n\n  module.controller('TemplateEditorCtrl', function($scope, datasourceSrv, templateSrv, templateValuesSrv, alertSrv) {\n\n    var replacementDefaults = {\n      type: 'query',\n      datasource: null,\n      refresh_on_load: false,\n      name: '',\n      options: [],\n      includeAll: false,\n      allFormat: 'glob',\n      multi: false,\n      multiFormat: 'glob',\n    };\n\n    $scope.init = function() {\n      $scope.editor = { index: 0 };\n      $scope.datasources = datasourceSrv.getMetricSources();\n      $scope.variables = templateSrv.variables;\n      $scope.reset();\n\n      $scope.$watch('editor.index', function(index) {\n        if ($scope.currentIsNew === false && index === 1) {\n          $scope.reset();\n        }\n      });\n    };\n\n    $scope.add = function() {\n      if ($scope.isValid()) {\n        $scope.variables.push($scope.current);\n        $scope.update();\n        $scope.updateSubmenuVisibility();\n      }\n    };\n\n    $scope.isValid = function() {\n      if (!$scope.current.name) {\n        $scope.appEvent('alert-warning', ['Validation', 'Template variable requires a name']);\n        return false;\n      }\n\n      if (!$scope.current.name.match(/^\\w+$/)) {\n        $scope.appEvent('alert-warning', ['Validation', 'Only word and digit characters are allowed in variable names']);\n        return false;\n      }\n\n      var sameName = _.findWhere($scope.variables, { name: $scope.current.name });\n      if (sameName && sameName !== $scope.current) {\n        $scope.appEvent('alert-warning', ['Validation', 'Variable with the same name already exists']);\n        return false;\n      }\n\n      return true;\n    };\n\n    $scope.runQuery = function() {\n      return templateValuesSrv.updateOptions($scope.current).then(function() {\n      }, function(err) {\n        alertSrv.set('Templating', 'Failed to run query for variable values: ' + err.message, 'error');\n      });\n    };\n\n    $scope.edit = function(variable) {\n      $scope.current = variable;\n      $scope.currentIsNew = false;\n      $scope.editor.index = 2;\n\n      if ($scope.current.datasource === void 0) {\n        $scope.current.datasource = null;\n        $scope.current.type = 'query';\n        $scope.current.allFormat = 'glob';\n      }\n    };\n\n    $scope.update = function() {\n      if ($scope.isValid()) {\n        $scope.runQuery().then(function() {\n          $scope.reset();\n          $scope.editor.index = 0;\n        });\n      }\n    };\n\n    $scope.reset = function() {\n      $scope.currentIsNew = true;\n      $scope.current = angular.copy(replacementDefaults);\n    };\n\n    $scope.typeChanged = function () {\n      if ($scope.current.type === 'interval') {\n        $scope.current.query = '1m,10m,30m,1h,6h,12h,1d,7d,14d,30d';\n      }\n      if ($scope.current.type === 'query') {\n        $scope.current.query = '';\n      }\n    };\n\n    $scope.removeVariable = function(variable) {\n      var index = _.indexOf($scope.variables, variable);\n      $scope.variables.splice(index, 1);\n      $scope.updateSubmenuVisibility();\n    };\n\n  });\n\n});\n","coverage":[1,null,null,null,null,null,null,1,null,1,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,null,0,0,0,null,null,null,null,0,0,0,0,0,null,null,null,0,0,0,0,null,null,0,0,0,null,null,0,0,0,0,null,null,0,null,null,0,0,null,0,null,null,null,0,0,0,0,null,0,0,0,0,null,null,null,0,0,0,0,0,null,null,null,null,0,0,0,null,null,0,0,0,null,0,0,null,null,null,0,0,0,0,null,null,null,null,null,null]}],"git":{"head":{"id":"697529d0e832fcfaa058698e87374f41dbec381c","author_name":"Torkel degaard","author_email":"torkel.odegaard@gmail.com","committer_name":"Torkel degaard","committer_email":"torkel.odegaard@gmail.com","message":"Worked on golang code coverage via coveralls"},"branch":"master","remotes":[{"name":"origin","url":"git@github.com:grafana/grafana.git"},{"name":"raintank","url":"git@github.com:raintank/grafana.git"}]},"run_at":"2015-05-03T09:50:01.522Z"}